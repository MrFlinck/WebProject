{"version":3,"names":["virtualTypes","require","_t","DEPRECATED_KEYS","DEPRECATED_ALIASES","FLIPPED_ALIAS_KEYS","TYPES","__internal__deprecationWarning","deprecationWarning","isVirtualType","type","isExplodedVisitor","visitor","_exploded","explode","nodeType","Object","keys","shouldIgnoreKey","parts","split","length","fns","part","verify","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","mergePair","aliases","deprecatedKey","deprecatedAlias","alias","existing","assign","_verified","Error","validateVisitorMethods","indexOf","visitors","visitorKey","path","val","concat","fn","TypeError","merge","states","wrapper","mergedVisitor","i","state","topVisitor","wrapWithStateOrWrapper","key","typeVisitor","nodeVisitor","oldVisitor","newVisitor","phase","Array","isArray","map","newFn","call","toString","obj","enter","exit","apply","arguments","dest","src"],"sources":["../src/visitors.ts"],"sourcesContent":["import * as virtualTypes from \"./path/lib/virtual-types\";\nimport type { Node } from \"@babel/types\";\nimport {\n  DEPRECATED_KEYS,\n  DEPRECATED_ALIASES,\n  FLIPPED_ALIAS_KEYS,\n  TYPES,\n  __internal__deprecationWarning as deprecationWarning,\n} from \"@babel/types\";\nimport type { ExplodedVisitor, NodePath, Visitor } from \"./index\";\nimport type { ExplVisitNode, VisitNodeFunction, VisitPhase } from \"./types\";\n\ntype VIRTUAL_TYPES = keyof typeof virtualTypes;\nfunction isVirtualType(type: string): type is VIRTUAL_TYPES {\n  return type in virtualTypes;\n}\nexport type VisitWrapper<S = any> = (\n  stateName: string | undefined,\n  visitorType: VisitPhase,\n  callback: VisitNodeFunction<S, Node>,\n) => VisitNodeFunction<S, Node>;\n\nexport function isExplodedVisitor(\n  visitor: Visitor,\n): visitor is ExplodedVisitor {\n  // @ts-expect-error _exploded is not defined on non-exploded Visitor\n  return visitor?._exploded;\n}\n\n/**\n * explode() will take a visitor object with all of the various shorthands\n * that we support, and validates & normalizes it into a common format, ready\n * to be used in traversal\n *\n * The various shorthands are:\n * * `Identifier() { ... }` -> `Identifier: { enter() { ... } }`\n * * `\"Identifier|NumericLiteral\": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`\n * * Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`\n * Other normalizations are:\n * * Visitors of virtual types are wrapped, so that they are only visited when\n *   their dynamic check passes\n * * `enter` and `exit` functions are wrapped in arrays, to ease merging of\n *   visitors\n */\nexport function explode<S>(visitor: Visitor<S>): ExplodedVisitor<S> {\n  if (isExplodedVisitor(visitor)) return visitor;\n  // @ts-expect-error `visitor` will be cast to ExplodedVisitor by this function\n  visitor._exploded = true;\n\n  // normalise pipes\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    const parts: Array<string> = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      // @ts-expect-error part will be verified by `verify` later\n      visitor[part] = fns;\n    }\n  }\n\n  // verify data structure\n  verify(visitor);\n\n  // make sure there's no __esModule type since this is because we're using loose mode\n  // and it sets __esModule to be enumerable on all modules :(\n  // @ts-expect-error ESModule interop\n  delete visitor.__esModule;\n\n  // ensure visitors are objects\n  ensureEntranceObjects(visitor);\n\n  // ensure enter/exit callbacks are arrays\n  ensureCallbackArrays(visitor);\n\n  // add type wrappers\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (!isVirtualType(nodeType)) continue;\n\n    // wrap all the functions\n    const fns = visitor[nodeType];\n    for (const type of Object.keys(fns)) {\n      // @ts-expect-error normalised as VisitNodeObject\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    const types = virtualTypes[nodeType];\n    if (types !== null) {\n      for (const type of types) {\n        // merge the visitor if necessary or just put it back in\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          // @ts-expect-error Expression produces too complex union\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  // add aliases\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n\n    if (nodeType in DEPRECATED_KEYS) {\n      const deprecatedKey = DEPRECATED_KEYS[nodeType];\n      deprecationWarning(nodeType, deprecatedKey, \"Visitor \");\n      aliases = [deprecatedKey];\n    } else if (nodeType in DEPRECATED_ALIASES) {\n      const deprecatedAlias =\n        DEPRECATED_ALIASES[nodeType as keyof typeof DEPRECATED_ALIASES];\n      deprecationWarning(nodeType, deprecatedAlias, \"Visitor \");\n      aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];\n    }\n\n    if (!aliases) continue;\n\n    const fns = visitor[nodeType];\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        // @ts-expect-error Expression produces a union type that is too complex to represent.\n        visitor[alias] = { ...fns };\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    ensureCallbackArrays(\n      // @ts-expect-error nodeType must present in visitor after previous validations\n      visitor[nodeType],\n    );\n  }\n\n  // @ts-expect-error explosion has been performed\n  return visitor as ExplodedVisitor;\n}\n\nexport function verify(visitor: Visitor) {\n  // @ts-expect-error _verified is not defined on non-verified Visitor.\n  // TODO: unify _verified and _exploded.\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\n      \"You passed `traverse()` a function when it expected a visitor object, \" +\n        \"are you sure you didn't mean `{ enter: Function }`?\",\n    );\n  }\n\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(\n        `You gave us a visitor for the node type ${nodeType} but it's not a valid type`,\n      );\n    }\n\n    const visitors = visitor[nodeType];\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          // verify that it just contains functions\n          validateVisitorMethods(\n            `${nodeType}.${visitorKey}`,\n            visitors[visitorKey],\n          );\n        } else {\n          throw new Error(\n            \"You passed `traverse()` a visitor object with the property \" +\n              `${nodeType} that has the invalid property ${visitorKey}`,\n          );\n        }\n      }\n    }\n  }\n\n  // @ts-expect-error _verified is not defined on non-verified Visitor.\n  // TODO: unify _verified and _exploded.\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(\n  path: string,\n  val: any,\n): asserts val is Function | Function[] {\n  const fns = [].concat(val);\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\n        `Non-function found defined in ${path} with type ${typeof fn}`,\n      );\n    }\n  }\n}\n\nexport function merge<State>(\n  visitors: Visitor<State>[],\n): ExplodedVisitor<State>;\nexport function merge(\n  visitors: Visitor<unknown>[],\n  states?: any[],\n  wrapper?: Function | null,\n): ExplodedVisitor<unknown>;\nexport function merge(\n  visitors: any[],\n  states: any[] = [],\n  wrapper?: VisitWrapper | null,\n): ExplodedVisitor {\n  // @ts-expect-error don't bother with internal flags so it can work with earlier @babel/core validations\n  const mergedVisitor: ExplodedVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = explode(visitors[i]);\n    const state = states[i];\n\n    let topVisitor: ExplVisitNode<unknown, Node> = visitor;\n    if (state || wrapper) {\n      topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);\n    }\n    mergePair(mergedVisitor, topVisitor);\n\n    for (const key of Object.keys(visitor) as (keyof ExplodedVisitor)[]) {\n      if (shouldIgnoreKey(key)) continue;\n\n      let typeVisitor = visitor[key];\n\n      // if we have state or wrapper then overload the callbacks to take it\n      if (state || wrapper) {\n        typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);\n      }\n\n      const nodeVisitor = (mergedVisitor[key] ||= {});\n      mergePair(nodeVisitor, typeVisitor);\n    }\n  }\n\n  if (process.env.BABEL_8_BREAKING) {\n    return {\n      ...mergedVisitor,\n      _exploded: true,\n      _verified: true,\n    };\n  }\n\n  return mergedVisitor;\n}\n\nfunction wrapWithStateOrWrapper<State>(\n  oldVisitor: ExplVisitNode<State, Node>,\n  state: State | null,\n  wrapper?: VisitWrapper<State> | null,\n): ExplVisitNode<State, Node> {\n  const newVisitor: ExplVisitNode<State, Node> = {};\n\n  for (const phase of [\"enter\", \"exit\"] as VisitPhase[]) {\n    let fns = oldVisitor[phase];\n\n    // not an enter/exit array of callbacks\n    if (!Array.isArray(fns)) continue;\n\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path: NodePath) {\n          fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        // @ts-expect-error Fixme: actually PluginPass.key (aka pluginAlias)?\n        newFn = wrapper(state?.key, phase, newFn);\n      }\n\n      // Override toString in case this function is printed, we want to print the wrapped function, same as we do in `wrapCheck`\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n\n    newVisitor[phase] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj: Visitor) {\n  for (const key of Object.keys(obj) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(key)) continue;\n\n    const fns = obj[key];\n    if (typeof fns === \"function\") {\n      // @ts-expect-error: Expression produces a union type that is too complex to represent.\n      obj[key] = { enter: fns };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj: Visitor) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(nodeType: VIRTUAL_TYPES, fn: Function) {\n  const newFn = function (this: unknown, path: NodePath) {\n    // @ts-expect-error: Expression produces a union type that is too complex to represent.\n    if (path[`is${nodeType}`]()) {\n      return fn.apply(this, arguments);\n    }\n  };\n  newFn.toString = () => fn.toString();\n  return newFn;\n}\n\nfunction shouldIgnoreKey(\n  key: string,\n): key is\n  | `_${string}`\n  | \"enter\"\n  | \"exit\"\n  | \"shouldSkip\"\n  | \"denylist\"\n  | \"noScope\"\n  | \"skipKeys\"\n  | \"blacklist\" {\n  // internal/hidden key\n  if (key[0] === \"_\") return true;\n\n  // ignore function keys\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  // ignore other options\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (key === \"blacklist\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/*\nfunction mergePair(\n  dest: ExplVisitNode<unknown, Node>,\n  src: ExplVisitNode<unknown, Node>,\n);\n*/\nfunction mergePair(dest: any, src: any) {\n  for (const phase of [\"enter\", \"exit\"] as VisitPhase[]) {\n    if (!src[phase]) continue;\n    dest[phase] = [].concat(dest[phase] || [], src[phase]);\n  }\n}\n"],"mappings":";;;;;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AAEA,IAAAC,EAAA,GAAAD,OAAA;AAMsB;EALpBE,eAAe;EACfC,kBAAkB;EAClBC,kBAAkB;EAClBC,KAAK;EACLC,8BAA8B,EAAIC;AAAkB,IAAAN,EAAA;AAMtD,SAASO,aAAaA,CAACC,IAAY,EAAyB;EAC1D,OAAOA,IAAI,IAAIV,YAAY;AAC7B;AAOO,SAASW,iBAAiBA,CAC/BC,OAAgB,EACY;EAE5B,OAAOA,OAAO,oBAAPA,OAAO,CAAEC,SAAS;AAC3B;AAiBO,SAASC,OAAOA,CAAIF,OAAmB,EAAsB;EAClE,IAAID,iBAAiB,CAACC,OAAO,CAAC,EAAE,OAAOA,OAAO;EAE9CA,OAAO,CAACC,SAAS,GAAG,IAAI;EAGxB,KAAK,MAAME,QAAQ,IAAIC,MAAM,CAACC,IAAI,CAACL,OAAO,CAAC,EAAuB;IAChE,IAAIM,eAAe,CAACH,QAAQ,CAAC,EAAE;IAE/B,MAAMI,KAAoB,GAAGJ,QAAQ,CAACK,KAAK,CAAC,GAAG,CAAC;IAChD,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;IAExB,MAAMC,GAAG,GAAGV,OAAO,CAACG,QAAQ,CAAC;IAC7B,OAAOH,OAAO,CAACG,QAAQ,CAAC;IAExB,KAAK,MAAMQ,IAAI,IAAIJ,KAAK,EAAE;MAExBP,OAAO,CAACW,IAAI,CAAC,GAAGD,GAAG;IACrB;EACF;EAGAE,MAAM,CAACZ,OAAO,CAAC;EAKf,OAAOA,OAAO,CAACa,UAAU;EAGzBC,qBAAqB,CAACd,OAAO,CAAC;EAG9Be,oBAAoB,CAACf,OAAO,CAAC;EAG7B,KAAK,MAAMG,QAAQ,IAAIC,MAAM,CAACC,IAAI,CAACL,OAAO,CAAC,EAAE;IAC3C,IAAIM,eAAe,CAACH,QAAQ,CAAC,EAAE;IAE/B,IAAI,CAACN,aAAa,CAACM,QAAQ,CAAC,EAAE;IAG9B,MAAMO,GAAG,GAAGV,OAAO,CAACG,QAAQ,CAAC;IAC7B,KAAK,MAAML,IAAI,IAAIM,MAAM,CAACC,IAAI,CAACK,GAAG,CAAC,EAAE;MAEnCA,GAAG,CAACZ,IAAI,CAAC,GAAGkB,SAAS,CAACb,QAAQ,EAAEO,GAAG,CAACZ,IAAI,CAAC,CAAC;IAC5C;IAGA,OAAOE,OAAO,CAACG,QAAQ,CAAC;IAExB,MAAMc,KAAK,GAAG7B,YAAY,CAACe,QAAQ,CAAC;IACpC,IAAIc,KAAK,KAAK,IAAI,EAAE;MAClB,KAAK,MAAMnB,IAAI,IAAImB,KAAK,EAAE;QAExB,IAAIjB,OAAO,CAACF,IAAI,CAAC,EAAE;UACjBoB,SAAS,CAAClB,OAAO,CAACF,IAAI,CAAC,EAAEY,GAAG,CAAC;QAC/B,CAAC,MAAM;UAELV,OAAO,CAACF,IAAI,CAAC,GAAGY,GAAG;QACrB;MACF;IACF,CAAC,MAAM;MACLQ,SAAS,CAAClB,OAAO,EAAEU,GAAG,CAAC;IACzB;EACF;EAGA,KAAK,MAAMP,QAAQ,IAAIC,MAAM,CAACC,IAAI,CAACL,OAAO,CAAC,EAAuB;IAChE,IAAIM,eAAe,CAACH,QAAQ,CAAC,EAAE;IAE/B,IAAIgB,OAAO,GAAG1B,kBAAkB,CAACU,QAAQ,CAAC;IAE1C,IAAIA,QAAQ,IAAIZ,eAAe,EAAE;MAC/B,MAAM6B,aAAa,GAAG7B,eAAe,CAACY,QAAQ,CAAC;MAC/CP,kBAAkB,CAACO,QAAQ,EAAEiB,aAAa,EAAE,UAAU,CAAC;MACvDD,OAAO,GAAG,CAACC,aAAa,CAAC;IAC3B,CAAC,MAAM,IAAIjB,QAAQ,IAAIX,kBAAkB,EAAE;MACzC,MAAM6B,eAAe,GACnB7B,kBAAkB,CAACW,QAAQ,CAAoC;MACjEP,kBAAkB,CAACO,QAAQ,EAAEkB,eAAe,EAAE,UAAU,CAAC;MACzDF,OAAO,GAAG1B,kBAAkB,CAAC4B,eAAe,CAAC;IAC/C;IAEA,IAAI,CAACF,OAAO,EAAE;IAEd,MAAMT,GAAG,GAAGV,OAAO,CAACG,QAAQ,CAAC;IAE7B,OAAOH,OAAO,CAACG,QAAQ,CAAC;IAExB,KAAK,MAAMmB,KAAK,IAAIH,OAAO,EAAE;MAC3B,MAAMI,QAAQ,GAAGvB,OAAO,CAACsB,KAAK,CAAC;MAC/B,IAAIC,QAAQ,EAAE;QACZL,SAAS,CAACK,QAAQ,EAAEb,GAAG,CAAC;MAC1B,CAAC,MAAM;QAELV,OAAO,CAACsB,KAAK,CAAC,GAAAlB,MAAA,CAAAoB,MAAA,KAAQd,GAAG,CAAE;MAC7B;IACF;EACF;EAEA,KAAK,MAAMP,QAAQ,IAAIC,MAAM,CAACC,IAAI,CAACL,OAAO,CAAC,EAAE;IAC3C,IAAIM,eAAe,CAACH,QAAQ,CAAC,EAAE;IAE/BY,oBAAoB,CAElBf,OAAO,CAACG,QAAQ,CAClB,CAAC;EACH;EAGA,OAAOH,OAAO;AAChB;AAEO,SAASY,MAAMA,CAACZ,OAAgB,EAAE;EAGvC,IAAIA,OAAO,CAACyB,SAAS,EAAE;EAEvB,IAAI,OAAOzB,OAAO,KAAK,UAAU,EAAE;IACjC,MAAM,IAAI0B,KAAK,CACb,wEAAwE,GACtE,qDACJ,CAAC;EACH;EAEA,KAAK,MAAMvB,QAAQ,IAAIC,MAAM,CAACC,IAAI,CAACL,OAAO,CAAC,EAAuB;IAChE,IAAIG,QAAQ,KAAK,OAAO,IAAIA,QAAQ,KAAK,MAAM,EAAE;MAC/CwB,sBAAsB,CAACxB,QAAQ,EAAEH,OAAO,CAACG,QAAQ,CAAC,CAAC;IACrD;IAEA,IAAIG,eAAe,CAACH,QAAQ,CAAC,EAAE;IAE/B,IAAIT,KAAK,CAACkC,OAAO,CAACzB,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC/B,MAAM,IAAIuB,KAAK,CACZ,2CAA0CvB,QAAS,4BACtD,CAAC;IACH;IAEA,MAAM0B,QAAQ,GAAG7B,OAAO,CAACG,QAAQ,CAAC;IAClC,IAAI,OAAO0B,QAAQ,KAAK,QAAQ,EAAE;MAChC,KAAK,MAAMC,UAAU,IAAI1B,MAAM,CAACC,IAAI,CAACwB,QAAQ,CAAC,EAAE;QAC9C,IAAIC,UAAU,KAAK,OAAO,IAAIA,UAAU,KAAK,MAAM,EAAE;UAEnDH,sBAAsB,CACnB,GAAExB,QAAS,IAAG2B,UAAW,EAAC,EAC3BD,QAAQ,CAACC,UAAU,CACrB,CAAC;QACH,CAAC,MAAM;UACL,MAAM,IAAIJ,KAAK,CACb,6DAA6D,GAC1D,GAAEvB,QAAS,kCAAiC2B,UAAW,EAC5D,CAAC;QACH;MACF;IACF;EACF;EAIA9B,OAAO,CAACyB,SAAS,GAAG,IAAI;AAC1B;AAEA,SAASE,sBAAsBA,CAC7BI,IAAY,EACZC,GAAQ,EAC8B;EACtC,MAAMtB,GAAG,GAAG,EAAE,CAACuB,MAAM,CAACD,GAAG,CAAC;EAC1B,KAAK,MAAME,EAAE,IAAIxB,GAAG,EAAE;IACpB,IAAI,OAAOwB,EAAE,KAAK,UAAU,EAAE;MAC5B,MAAM,IAAIC,SAAS,CAChB,iCAAgCJ,IAAK,cAAa,OAAOG,EAAG,EAC/D,CAAC><Digits>9</Digits></Segment>
    </Segment>
    
  </Segment>
  <!-- End Row 2 -->

  <Segment>
    <!-- Row 3 -->
    <!-- No fall back at this level -->
    <Digits>3</Digits>
    
    <!-- Column 0 -->
    <Segment>
      <Region>GR</Region>
      <Digits>0</Digits>
      <Segment><Region>CA</Region><Digits>2</Digits></Segment> <!-- * EXCEPTION * Fido in CA uses MCC 302 -->
    </Segment>

    <!-- Column 1 -->
    <Segment><Region>NL</Region><Digits>1</Digits></Segment>

    <!-- Column 2 -->
    <Segment><Region>BE</Region><Digits>2</Digits></Segment>

    <!-- Column 3 -->
    <Segment><Region>FR</Region><Digits>3</Digits></Segment>
    
    <!-- Column 4 -->
    <Segment><Region>ES</Region><Digits>4</Digits></Segment>

    <!-- Column 5 -->
    <Segment>
      <Digits>5</Digits>
      <Segment><Region>GI</Region><Digits>0</Digits></Segment>
      <Segment><Region>PT</Region><Digits>1</Digits></Segment>
      <Segment><Region>LU</Region><Digits>2</Digits></Segment>
      <Segment><Region>IE</Region><Digits>3</Digits></Segment>
      <Segment><Region>IS</Region><Digits>4</Digits></Segment>
      <Segment><Region>AL</Region><Digits>5</Digits></Segment>
      <Segment><Region>MT</Region><Digits>6</Digits></Segment>
      <Segment><Region>CY</Region><Digits>7</Digits></Segment>
      <Segment><Region>FI</Region><Digits>8</Digits></Segment>
      <!-- <Segment><Region>AX</Region><Digits>8</Digits></Segment> * EXCEPTION * Currently no way to disambiguate between FI and AX -->
      <Segment><Region>BG</Region><Digits>9</Digits></Segment>
    </Segment>
    
    <!-- Column 6 -->
    <Segment><Region>HU</Region><Digits>6</Digits></Segment>
    
    <!-- Column 7 -->
    <Segment>
      <Digits>7</Digits>
      <Segment><Region>LT</Region><Digits>0</Digits></Segment>
      <Segment><Region>LV</Region><Digits>1</Digits></Segment>
      <Segment><Region>EE</Region><Digits>2</Digits></Segment>
      <Segment><Region>MD</Region><Digits>3</Digits></Segment>
      <Segment><Region>AM</Region><Digits>4</Digits></Segment>
      <!-- <Segment><Region>QN</Region><Digits>4</Digits></Segment> * EXCEPTION * Currently no way to disambiguate between AM and QN -->
      <Segment><Region>BY</Region><Digits>5</Digits></Segment>
      <Segment><Region>AD</Region><Digits>6</Digits></Segment>
      <Segment><Region>MC</Region><Digits>7</Digits></Segment>
      <Segment><Region>SM</Region><Digits>8</Digits></Segment>
      <Segment><Region>VA</Region><Digits>9</Digits></Segment>
    </Segment>
    
    <!-- Column 8 -->
    <Segment>
      <Digits>8</Digits>
      <Segment><Region>UA</Region><Digits>0</Digits></Segment>
      <Segment><Region>RS</Region><Digits>1</Digits></Segment>
      <Segment><Region>ME</Region><Digits>2</Digits></Segment>
      <Segment><Region>XK</Region><Digits>3</Digits></Segment>
      <Segment><Region>HR</Region><Digits>5</Digits></Segment>
      <Segment><Region>SI</Region><Digits>6</Digits></Segment>
      <Segment><Region>BA</Region><Digits>7</Digits></Segment>
      <Segment><Region>EU</Region><Digits>8</Digits></Segment>
      <Segment><Region>MK</Region><Digits>9</Digits></Segment>
    </Segment>
    
    <!-- Colum