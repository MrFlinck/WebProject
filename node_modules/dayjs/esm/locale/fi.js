, type and data to be returned
    $finalName = GetValueDisplayName -ValueName $ValueName
    $finalType = $keyInfo.GetValueKind($ValueName)
    $finalData = $valData
    
    # Special case: For Binary type data we convert the received bytes back to a readable hex-strin
    if ($finalType -ieq "Binary")
    {
        $finalData = ConvertByteArrayToHexString -Data $valData    
    }

    # Populate all config in the return object        
    $retVal.ValueName = $finalName
    $retVal.ValueType = $finalType
    $retVal.Data =  $finalData

    # If the control reaches here, both the $Key and the $ValueName have been found, query is fully successful
    Write-Verbose ($localizedData.RegValueExists -f "$Key\$ValueName", $retVal.ValueType, (ArrayToString $retVal.Data))

    return $retVal
}

#------------------------------
# The Get-TargetResource cmdlet
#------------------------------
FUNCTION Get-TargetResource
{    
	param
	(	
        [Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[System.String]
		$Key,
        	        
        [Parameter(Mandatory)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        [System.String]
		$ValueName,

        # Special-case: Used only as a boolean flag (along with ValueType) to determine if the target entity is the Default Value or the key itself.
		[System.String[]]
		$ValueData,

        # Special-case: Used only as a boolean flag (along with ValueData) to determine if the target entity is the Default Value or the key itself.
		[System.String]
		$ValueType
	)    
        
    # If $ValueName is "" and ValueType and ValueData are both not specified, then we target the key itself (not Default Value)
    if ($ValueName -eq "" -and !$PSBoundParameters.ContainsKey("ValueType") -and !$PSBoundParameters.ContainsKey("ValueData"))
    {
        $retVal = Get-TargetResourceInternal -Key $Key
    }
    else
    {
        $retVal = Get-TargetResourceInternal -Key $Key -ValueName $ValueName
        
        if ($retVal.Ensure -eq 'Present')
        {                                               
            [string[]]$retVal.ValueData += $retVal.Data
            
            if ($retVal.ValueType -ieq "MultiString")
            {
                $retVal.ValueData = $retVal.Data
            }
        }        
    }    
        
    $retVal.Remove("Data")

    return $retVal
}


#------------------------------
# The Set-TargetResource cmdlet
#------------------------------
FUNCTION Set-TargetResource
{
    [CmdletBinding(SupportsShouldProcess=$true)]