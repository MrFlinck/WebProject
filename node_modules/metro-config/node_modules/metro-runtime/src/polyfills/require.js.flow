/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 * @oncall react_native
 * @polyfill
 */

'use strict';

/* eslint-disable no-bitwise */

declare var __DEV__: boolean;
declare var __METRO_GLOBAL_PREFIX__: string;

// A simpler $ArrayLike<T>. Not iterable and doesn't have a `length`.
// This is compatible with actual arrays as well as with objects that look like
// {0: 'value', 1: '...'}
type ArrayIndexable<T> = interface {
  +[indexer: number]: T,
};
type DependencyMap = $ReadOnly<
  ArrayIndexable<ModuleID> & {
    paths?: {[id: ModuleID]: string},
  },
>;
type InverseDependencyMap = {[key: ModuleID]: Array<ModuleID>, ...};
type Exports = any;
type FactoryFn = (
  global: Object,
  require: RequireFn,
  metroImportDefault: RequireFn,
  metroImportAll: RequireFn,
  moduleObject: {exports: {...}, ...},
  exports: {...},
  dependencyMap: ?DependencyMap,
) => void;
type HotModuleReloadingCallback = () => void;
type HotModuleReloadingData = {
  _acceptCallback: ?HotModuleReloadingCallback,
  _disposeCallback: ?HotModuleReloadingCallback,
  _didAccept: boolean,
  accept: (callback?: HotModuleReloadingCallback) => void,
  dispose: (callback?: HotModuleReloadingCallback) => void,
};
type ModuleID = number;
type Module = {
  id?: ModuleID,
  exports: Exports,
  hot?: HotModuleReloadingData,
  ...
};
type ModuleDefinition = {
  dependencyMap: ?DependencyMap,
  error?: any,
  factory: FactoryFn,
  hasError: boolean,
  hot?: HotModuleReloadingData,
  importedAll: any,
  importedDefault: any,
  isInitialized: boolean,
  path?: string,
  publicModule: Module,
  verboseName?: string,
};
type ModuleList = {
  [number]: ?ModuleDefinition,
  __proto__: null,
  ...
};
export type RequireFn = (id: ModuleID | VerboseModuleNameForDev) => Exports;
export type DefineFn = (
  factory: FactoryFn,
  moduleId: number,
  dependencyMap?: DependencyMap,
  verboseName?: string,
  inverseDependencies?: InverseDependencyMap,
) => void;

type VerboseModuleNameForDev = string;
type ModuleDefiner = (moduleId: ModuleID) => void;

global.__r = (metroRequire: RequireFn);
global[`${__METRO_GLOBAL_PREFIX__}__d`] = (define: DefineFn);
global.__c = clear;
global.__registerSegment = registerSegment;

var modules = clear();

// Don't use a Symbol here, it would pull in an extra polyfill with all sorts of
// additional stuff (e.g. Array.from).
const EMPTY = {};
const CYCLE_DETECTED = {};
const {hasOwnProperty} = {};

if (__DEV__) {
  global.$RefreshReg$ = () => {};
  global.$RefreshSig$ = () => type => type;
}

function clear(): ModuleList {
  modules = (Object.create(null): ModuleList);

  // We return modules here so that we can assign an initial value to modules
  // when defining it. Otherwise, we would have to do "let modules = null",
  // which will force us to add "nullthrows" everywhere.
  return modules;
}

if (__DEV__) {
  var verboseNamesToModuleIds: {
    [key: string]: number,
    __proto__: null,
    ...
  } = Object.create(null);
  var initializingModuleIds: Array<number> = [];
}

function define(
  factory: FactoryFn,
  moduleId: number,
  dependencyMap?: DependencyMap,
): void {
  if (modules[moduleId] != null) {
    if (__DEV__) {
      // (We take `inverseDependencies` from `arguments` to avoid an unused
      // named parameter in `define` in production.
      const inverseDependencies = arguments[4];

      // If the module has already been defined and the define method has been
      // called with inverseDependencies, we can hot reload it.
      if (inverseDependencies) {
        global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
      }
    }

    // prevent repeated calls to `global.nativeRequire` to overwrite modules
    // that are already loaded
    return;
  }

  const mod: ModuleDefinition = {
    dependencyMap,
    factory,
    hasError: false,
    importedAll: EMPTY,
    importedDefault: EMPTY,
    isInitialized: false,
    publicModule: {exports: {}},
  };

  modules[moduleId] = mod;

  if (__DEV__) {
    // HMR
    mod.hot = createHotReloadingObject();

    // DEBUGGABLE MODULES NAMES
    // we take `verboseName` from `arguments` to avoid an unused named parameter
    // in `define` in production.
    const verboseName: string | void = arguments[3];
    if (verboseName) {
      mod.verboseName = verboseName;
      verboseNamesToModuleIds[verboseName] = moduleId;
    }
  }
}

function metroRequire(moduleId: ModuleID | VerboseModuleNameForDev): Exports {
  if (__DEV__ && typeof moduleId === 'string') {
    const verboseName = moduleId;
    moduleId = verboseNamesToModuleIds[verboseName];
    if (moduleId == null) {
      throw new Error(`Unknown named module: "${verboseName}"`);
    } else {
      console.warn(
        `Requiring module "${verboseName}" by name is only supported for ` +
          'debugging purposes and will BREAK IN PRODUCTION!',
      );
    }
  }

  //$FlowFixMe: at this point we know that moduleId is a number
  const moduleIdReallyIsNumber: number = moduleId;

  if (__DEV__) {
    const initializingIndex = initializingModuleIds.indexOf(
      moduleIdReallyIsNumber,
    );
    if (initializingIndex !== -1) {
      const cycle = initializingModuleIds
        .slice(initializingIndex)
        .map((id: number) =>
          modules[id] ? modules[id].verboseName : '[unknown]',
        );

      if (shouldPrintRequireCycle(cycle)) {
        cycle.push(cycle[0]); // We want to print A -> B -> A:
        console.warn(
          `Require cycle: ${cycle.join(' -> ')}\n\n` +
            'Require cycles are allowed, but can result in uninitialized values. ' +
            'Consider refactoring to remove the need for a cycle.',
        );
      }
    }
  }

  const module = modules[moduleIdReallyIsNumber];

  return module && module.isInitialized
    ? module.publicModule.exports
    : guardedLoadModule(moduleIdReallyIsNumber, module);
}

// We print require cycles unless they match a pattern in the
// `requireCycleIgnorePatterns` configuration.
function shouldPrintRequireCycle(modules: $ReadOnlyArray<?string>): boolean {
  const regExps =
    global[__METRO_GLOBAL_PREFIX__ + '__requireCycleIgnorePatterns'];
  if (!Array.isArray(regExps)) {
    return true;
  }

  const isIgnored = (module: ?string) =>
    module != null && regExps.some(regExp => regExp.test(module));

  // Print the cycle unless any part of it is ignored
  return modules.every(module => !isIgnored(module));
}

function metroImportDefault(
  moduleId: ModuleID | VerboseModuleNameForDev,
): any | Exports {
  if (__DEV__ && typeof moduleId === 'string') {
    const verboseName = moduleId;
    moduleId = verboseNamesToModuleIds[verboseName];
  }

  //$FlowFixMe: at this point we know that moduleId is a number
  const moduleIdReallyIsNumber: number = moduleId;

  if (
    modules[moduleIdReallyIsNumber] &&
    modules[moduleIdReallyIsNumber].importedDefault !== EMPTY
  ) {
    return modules[moduleIdReallyIsNumber].importedDefault;
  }

  const exports: Exports = metroRequire(moduleIdReallyIsNumber);
  const importedDefault: any | Exports =
    exports && exports.__esModule ? exports.default : exports;

  // $FlowFixMe The metroRequire call above will throw if modules[id] is null
  return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);
}
metroRequire.importDefault = metroImportDefault;

function metroImportAll(
  moduleId: ModuleID | VerboseModuleNameForDev | number,
): any | Exports | {[string]: any} {
  if (__DEV__ && typeof moduleId === 'string') {
    const verboseName = moduleId;
    moduleId = verboseNamesToModuleIds[verboseName];
  }

  //$FlowFixMe: at this point we know that moduleId is a number
  const moduleIdReallyIsNumber: number = moduleId;

  if (
    modules[moduleIdReallyIsNumber] &&
    modules[moduleIdReallyIsNumber].importedAll !== EMPTY
  ) {
    return modules[moduleIdReallyIsNumber].importedAll;
  }

  const exports: Exports = metroRequire(moduleIdReallyIsNumber);
  let importedAll: Exports | {[string]: any};

  if (exports && exports.__esModule) {
    importedAll = exports;
  } else {
    importedAll = ({}: {[string]: any});

    // Refrain from using Object.assign, it has to work in ES3 environments.
    if (exports) {
      for (const key: string in exports) {
        if (hasOwnProperty.call(exports, key)) {
          importedAll[key] = exports[key];
        }
      }
    }

    importedAll.default = exports;
  }

  // $FlowFixMe The metroRequire call above will throw if modules[id] is null
  return (modules[moduleIdReallyIsNumber].importedAll = importedAll);
}
metroRequire.importAll = metroImportAll;

// The `require.context()` syntax is never executed in the runtime because it is converted
// to `require()` in `metro/src/ModuleGraph/worker/collectDependencies.js` after collecting
// dependencies. If the feature flag is not enabled then the conversion never takes place and this error is thrown (development only).
metroRequire.context = function fallbackRequireContext() {
  if (__DEV__) {
    throw new Error(
      'The experimental Metro feature `require.context` is not enabled in your project.\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.',
    );
  }
  throw new Error(
    'The experimental Metro feature `require.context` is not enabled in your project.',
  );
};

// `require.resolveWeak()` is a compile-time primitive (see collectDependencies.js)
metroRequire.resolveWeak = function fallbackRequireResolveWeak() {
  if (__DEV__) {
    throw new Error(
      'require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.',
    );
  }
  throw new Error('require.resolveWeak cannot be called dynamically.');
};

let inGuard = false;
function guardedLoadModule(
  moduleId: ModuleID,
  module: ?ModuleDefinition,
): Exports {
  if (!inGuard && global.ErrorUtils) {
    inGuard = true;
    let returnValue;
    try {
      returnValue = loadModuleImplementation(moduleId, module);
    } catch (e) {
      // TODO: (moti) T48204692 Type this use of ErrorUtils.
      global.ErrorUtils.reportFatalError(e);
    }
    inGuard = false;
    return returnValue;
  } else {
    return loadModuleImplementation(moduleId, module);
  }
}

const ID_MASK_SHIFT = 16;
const LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;

function unpackModuleId(moduleId: ModuleID): {
  localId: number,
  segmentId: number,
  ...
} {
  const segmentId = moduleId >>> ID_MASK_SHIFT;
  const localId = moduleId & LOCAL_ID_MASK;
  return {segmentId, localId};
}
metroRequire.unpackModuleId = unpackModuleId;

function packModuleId(value: {
  localId: number,
  segmentId: number,
  ...
}): ModuleID {
  return (value.segmentId << ID_MASK_SHIFT) + value.localId;
}
metroRequire.packModuleId = packModuleId;

const moduleDefinersBySegmentID: Array<?ModuleDefiner> = [];
const definingSegmentByModuleID: Map<ModuleID, number> = new Map();

function registerSegment(
  segmentId: number,
  moduleDefiner: ModuleDefiner,
  moduleIds: ?$ReadOnlyArray<ModuleID>,
): void {
  moduleDefinersBySegmentID[segmentId] = moduleDefiner;
  if (__DEV__) {
    if (segmentId === 0 && moduleIds) {
      throw new Error(
        'registerSegment: Expected moduleIds to be null for main segment',
      );
    }
    if (segmentId !== 0 && !moduleIds) {
      throw new Error(
        'registerSegment: Expected moduleIds to be passed for segment #' +
          segmentId,
      );
    }
  }
  if (moduleIds) {
    moduleIds.forEach(moduleId => {
      if (!modules[moduleId] && !definingSegmentByModuleID.has(moduleId)) {
        definingSegmentByModuleID.set(moduleId, segmentId);
      }
    });
  }
}

function loadModuleImplementation(
  moduleId: ModuleID,
  module: ?ModuleDefinition,
): Exports {
  if (!module && moduleDefinersBySegmentID.length > 0) {
    const segmentId = definingSegmentByModuleID.get(moduleId) ?? 0;
    const definer = moduleDefinersBySegmentID[segmentId];
    if (definer != null) {
      definer(moduleId);
      module = modules[moduleId];
      definingSegmentByModuleID.delete(moduleId);
    }
  }

  const nativeRequire = global.nativeRequire;
  if (!module && nativeRequire) {
    const {segmentId, localId} = unpackModuleId(moduleId);
    nativeRequire(localId, segmentId);
    module = modules[moduleId];
  }

  if (!module) {
    throw unknownModuleError(moduleId);
  }

  if (module.hasError) {
    throw module.error;
  }

  if (__DEV__) {
    var Systrace = requireSystrace();
    var Refresh = requireRefresh();
  }

  // We must optimistically mark module as initialized before running the
  // factory to keep any require cycles inside the factory from causing an
  // infinite require loop.
  module.isInitialized = true;

  const {factory, dependencyMap} = module;
  if (__DEV__) {
    initializingModuleIds.push(moduleId);
  }
  try {
    if (__DEV__) {
      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists
      Systrace.beginEvent('JS_require_' + (module.verboseName || moduleId));
    }

    const moduleObject: Module = module.publicModule;

    if (__DEV__) {
      moduleObject.hot = module.hot;

      var prevRefreshReg = global.$RefreshReg$;
      var prevRefreshSig = global.$RefreshSig$;
      if (Refresh != null) {
        const RefreshRuntime = Refresh;
        global.$RefreshReg$ = (type, id) => {
          RefreshRuntime.register(type, moduleId + ' ' + id);
        };
        global.$RefreshSig$ =
          RefreshRuntime.createSignatureFunctionForTransform;
      }
    }
    moduleObject.id = moduleId;

    // keep args in sync with with defineModuleCode in
    // metro/src/Resolver/index.js
    // and metro/src/ModuleGraph/worker.js
    factory(
      global,
      metroRequire,
      metroImportDefault,
      metroImportAll,
      moduleObject,
      moduleObject.exports,
      dependencyMap,
    );

    // avoid removing factory in DEV mode as it breaks HMR
    if (!__DEV__) {
      // $FlowFixMe: This is only sound because we never access `factory` again
      module.factory = undefined;
      module.dependencyMap = undefined;
    }

    if (__DEV__) {
      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists
      Systrace.endEvent();

      if (Refresh != null) {
        registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
      }
    }

    return moduleObject.exports;
  } catch (e) {
    module.hasError = true;
    module.error = e;
    module.isInitialized = false;
    module.publicModule.exports = undefined;
    throw e;
  } finally {
    if (__DEV__) {
      if (initializingModuleIds.pop() !== moduleId) {
        throw new Error(
          'initializingModuleIds is corrupt; something is terribly wrong',
        );
      }
      global.$RefreshReg$ = prevRefreshReg;
      global.$RefreshSig$ = prevRefreshSig;
    }
  }
}

function unknownModuleError(id: ModuleID): Error {
  let message = 'Requiring unknown module "' + id + '".';
  if (__DEV__) {
    message +=
      ' If you are sure the module exists, try restarting Metro. ' +
      'You may also want to run `yarn` or `npm install`.';
  }
  return Error(message);
}

if (__DEV__) {
  // $FlowFixMe[prop-missing]
  metroRequire.Systrace = {
    beginEvent: (): void => {},
    endEvent: (): void => {},
  };
  // $FlowFixMe[prop-missing]
  metroRequire.getModules = (): ModuleList => {
    return modules;
  };

  // HOT MODULE RELOADING
  var createHotReloadingObject = function () {
    const hot: HotModuleReloadingData = {
      _acceptCallback: null,
      _disposeCallback: null,
      _didAccept: false,
      accept: (callback?: HotModuleReloadingCallback): void => {
        hot._didAccept = true;
        hot._acceptCallback = callback;
      },
      dispose: (callback?: HotModuleReloadingCallback): void => {
        hot._disposeCallback = callback;
      },
    };
    return hot;
  };

  let reactRefreshTimeout: null | TimeoutID = null;

  const metroHotUpdateModule = function (
    id: ModuleID,
    factory: FactoryFn,
    dependencyMap: DependencyMap,
    inverseDependencies: InverseDependencyMap,
  ) {
    const mod = modules[id];
    if (!mod) {
      if (factory) {
        // New modules are going to be handled by the define() method.
        return;
      }
      throw unknownModuleError(id);
    }

    if (!mod.hasError && !mod.isInitialized) {
      // The module hasn't actually been executed yet,
      // so we can always safely replace it.
      mod.factory = factory;
      mod.dependencyMap = dependencyMap;
      return;
    }

    const Refresh = requireRefresh();
    const refreshBoundaryIDs = new Set<ModuleID>();

    // In this loop, we will traverse the dependency tree upwards from the
    // changed module. Updates "bubble" up to the closest accepted parent.
    //
    // If we reach the module root and nothing along the way accepted the update,
    // we know hot reload is going to fail. In that case we return false.
    //
    // The main purpose of this loop is to figure out whether it's safe to apply
    // a hot update. It is only safe when the update was accepted somewhere
    // along the way upwards for each of its parent dependency module chains.
    //
    // We perform a topological sort because we may discover the same
    // module more than once in the list of things to re-execute, and
    // we want to execute modules before modules that depend on them.
    //
    // If we didn't have this check, we'd risk re-evaluating modules that
    // have side effects and lead to confusing and meaningless crashes.

    let didBailOut = false;
    let updatedModuleIDs;
    try {
      updatedModuleIDs = topologicalSort(
        [id], // Start with the changed module and go upwards
        pendingID => {
          const pendingModule = modules[pendingID];
          if (pendingModule == null) {
            // Nothing to do.
            return [];
          }
          const pendingHot = pendingModule.hot;
          if (pendingHot == null) {
            throw new Error(
              '[Refresh] Expected module.hot to always exist in DEV.',
            );
          }
          // A module can be accepted manually from within itself.
          let canAccept = pendingHot._didAccept;
          if (!canAccept && Refresh != null) {
            // Or React Refresh may mark it accepted based on exports.
            const isBoundary = isReactRefreshBoundary(
              Refresh,
              pendingModule.publicModule.exports,
            );
            if (isBoundary) {
              canAccept = true;
              refreshBoundaryIDs.add(pendingID);
            }
          }
          if (canAccept) {
            // Don't look at parents.
            return [];
          }
          // If we bubble through the roof, there is no way to do a hot update.
          // Bail out altogether. This is the failure case.
          const parentIDs = inverseDependencies[pendingID];
          if (parentIDs.length === 0) {
            // Reload the app because the hot reload can't succeed.
            // This should work both on web and React Native.
            performFullRefresh('No root boundary', {
              source: mod,
              failed: pendingModule,
            });
            didBailOut = true;
            return [];
          }
          // This module can't handle the update but maybe all its parents can?
          // Put them all in the queue to run the same set of checks.
          return parentIDs;
        },
        () => didBailOut, // Should we stop?
      ).reverse();
    } catch (e) {
      if (e === CYCLE_DETECTED) {
        performFullRefresh('Dependency cycle', {
          source: mod,
        });
        return;
      }
      throw e;
    }

    if (didBailOut) {
      return;
    }

    // If we reached here, it is likely that hot reload will be successful.
    // Run the actual factories.
    const seenModuleIDs = new Set<ModuleID>();
    for (let i = 0; i < updatedModuleIDs.length; i++) {
      const updatedID = updatedModuleIDs[i];
      if (seenModuleIDs.has(updatedID)) {
        continue;
      }
      seenModuleIDs.add(updatedID);

      const updatedMod = modules[updatedID];
      if (updatedMod == null) {
        throw new Error('[Refresh] Expected to find the updated module.');
      }
      const prevExports = updatedMod.publicModule.exports;
      const didError = runUpdatedModule(
        updatedID,
        updatedID === id ? factory : undefined,
        updatedID === id ? dependencyMap : undefined,
      );
      const nextExports = updatedMod.publicModule.exports;

      if (didError) {
        // The user was shown a redbox about module initialization.
        // There's nothing for us to do here until it's fixed.
        return;
      }

      if (refreshBoundaryIDs.has(updatedID)) {
        // Since we just executed the code for it, it's possible
        // that the new exports make it ineligible for being a boundary.
        const isNoLongerABoundary = !isReactRefreshBoundary(
          Refresh,
          nextExports,
        );
        // It can also become ineligible if its exports are incompatible
        // with the previous exports.
        // For example, if you add/remove/change exports, we'll want
        // to re-execute the importing modules, and force those components
        // to re-render. Similarly, if you convert a class component
        // to a function, we want to invalidate the boundary.
        const didInvalidate = shouldInvalidateReactRefreshBoundary(
          Refresh,
          prevExports,
          nextExports,
        );
        if (isNoLongerABoundary || didInvalidate) {
          // We'll be conservative. The only case in which we won't do a full
          // reload is if all parent modules are also refresh boundaries.
          // In that case we'll add them to the current queue.
          const parentIDs = inverseDependencies[updatedID];
          if (parentIDs.length === 0) {
            // Looks like we bubbled to the root. Can't recover from that.
            performFullRefresh(
              isNoLongerABoundary
                ? 'No longer a boundary'
                : 'Invalidated boundary',
              {
                source: mod,
                failed: updatedMod,
              },
            );
            return;
          }
          // Schedule all parent refresh boundaries to re-run in this loop.
          for (let j = 0; j < parentIDs.length; j++) {
            const parentID = parentIDs[j];
            const parentMod = modules[parentID];
            if (parentMod == null) {
              throw new Error('[Refresh] Expected to find parent module.');
            }
            const canAcceptParent = isReactRefreshBoundary(
              Refresh,
              parentMod.publicModule.exports,
            );
            if (canAcceptParent) {
              // All parents will have to re-run too.
              refreshBoundaryIDs.add(parentID);
              updatedModuleIDs.push(parentID);
            } else {
              performFullRefresh('Invalidated boundary', {
                source: mod,
                failed: parentMod,
              });
              return;
            }
          }
        }
      }
    }

    if (Refresh != null) {
      // Debounce a little in case there are multiple updates queued up.
      // This is also useful because __accept may be called multiple times.
      if (reactRefreshTimeout == null) {
        reactRefreshTimeout = setTimeout(() => {
          reactRefreshTimeout = null;
          // Update React components.
          Refresh.performReactRefresh();
        }, 30);
      }
    }
  };

  const topologicalSort = function <T>(
    roots: Array<T>,
    getEdges: T => Array<T>,
    earlyStop: T => boolean,
  ): Array<T> {
    const result = [];
    const visited = new Set<mixed>();
    const stack = new Set<mixed>();
    function traverseDependentNodes(node: T): void {
      if (stack.has(node)) {
        throw CYCLE_DETECTED;
      }
      if (visited.has(node)) {
        return;
      }
      visited.add(node);
      stack.add(node);
      const dependentNodes = getEdges(node);
      if (earlyStop(node)) {
        stack.delete(node);
        return;
      }
      dependentNodes.forEach(dependent => {
        traverseDependentNodes(dependent);
      });
      stack.delete(node);
      result.push(node 111.831247,187.560179 111.831247,187.560179 L100.767247,191.103351 Z" id="Fill-45" fill="#2B579A"></path>
                                <path d="M100.767247,191.103351 C104.078212,189.970306 104.078212,189.970306 104.078212,189.970306 C94.1744,158.024113 94.1744,158.024113 94.1744,158.024113 C93.6016,155.614024 91.5820235,153.914447 89.1448471,153.631153 C56.9966118,150.0736 56.9966118,150.0736 56.9966118,150.0736 C56.7101176,152.920565 56.7101176,152.920565 56.7101176,152.920565 C90.4362353,156.607812 90.4362353,156.607812 90.4362353,156.607812 L100.767247,191.103351 Z" id="Fill-46" fill="#002050"></path>
                                <path d="M95.7522824,145.536565 C70.1967059,142.704 70.1967059,142.704 70.1967059,142.704 C69.9103059,145.253271 69.9103059,145.253271 69.9103059,145.253271 C100.335153,148.657224 100.335153,148.657224 100.335153,148.657224 C99.4758588,146.813647 97.7572706,145.680565 95.7522824,145.536565 Z" id="Fill-47" fill="#2B579A"></path>
                                <path d="M70.0559059,107.641882 C69.0510118,106.5088 67.9052235,102.523953 62.4436706,102.523953 C61.1570824,102.523953 55.5644235,102.523953 54.1322353,102.523953 C48.8162824,102.523953 48.0977882,108.064376 47.5248941,109.202259 C45.8063059,113.7344 44.9470118,133.039435 44.9470118,140.850729 C44.9470118,148.801318 44.9470118,153.631153 49.5298824,153.631153 C59.2928941,153.631153 59.2928941,153.631153 59.2928941,153.631153 C63.8903529,153.631153 76.2311529,156.468612 76.2311529,148.657224 C76.2311529,140.706729 72.4929882,110.618541 70.0559059,107.641882 Z" id="Fill-48" fill="#6EB38A"></path>
                                <path d="M65.6089412,103.090447 C64.7496471,102.667953 63.7495529,102.523953 62.4436706,102.523953 C61.1570824,102.523953 55.5644235,102.523953 54.2730353,102.523953 C49.9619765,102.523953 48.6705882,105.783906 48.0977882,107.781082 C48.9570824,106.5088 50.1076706,104.650824 52.3990588,104.228329 C53.8458353,103.945035 60.5793882,103.661835 62.0163765,103.373741 C63.3174588,103.234541 64.4632471,103.234541 65.4681412,103.373741 L65.6089412,103.090447 Z" id="Fill-49" fill="#9FCDB3"></path>
                                <path d="M109.130353,62.5035294 C108.557553,62.5035294 107.984659,60.2374588 107.125365,60.2374588 C106.261271,60.2374588 104.960188,55.9741176 104.960188,55.9741176 C104.673694,55.4076235 104.960188,54.8362353 105.532988,54.5530353 C106.105882,54.2697412 106.693271,54.4137412 106.979765,54.9803294 C109.989647,60.9480471 109.989647,60.9480471 109.989647,60.9480471 C110.276141,61.5145412 109.989647,62.0810353 109.416847,62.3643294 C109.276047,62.5035294 109.130353,62.5035294 109.130353,62.5035294 Z" id="Fill-50" fill="#CB8C84"></path>
                                <path d="M61.4435765,193.086193 C60.2929882,193.086193 59.1472,191.953139 59.1472,190.680866 C59.1472,160.304612 59.1472,160.304612 59.1472,160.304612 C59.1472,159.017929 60.2929882,158.024113 61.4435765,158.024113 C62.7300706,158.024113 63.8903529,159.017929 63.8903529,160.304612 C63.8903529,190.680866 63.8903529,190.680866 63.8903529,190.680866 C63.8903529,191.953139 62.7300706,193.086193 61.4435765,193.086193 Z" id="Fill-62" fill="#3C3C3C"></path>
                                <path d="M75.9447529,153.631153 C63.1718588,153.631153 63.1718588,153.631153 63.1718588,153.631153 C47.0928,153.631153 47.0928,153.631153 47.0928,153.631153 C43.3546353,153.631153 40.3446588,156.607812 40.3446588,160.304612 C82.6928941,160.304612 82.6928941,160.304612 82.6928941,160.304612 C82.6928941,156.607812 79.6732235,153.631153 75.9447529,153.631153 Z" id="Fill-63" fill="#666666"></path>
                                <path d="M58.8608,154.197647 C71.6336941,154.197647 71.6336941,154.197647 71.6336941,154.197647 C75.0854588,154.197647 77.9497412,156.891106 78.2362353,160.304612 C82.6928941,160.304612 82.6928941,160.304612 82.6928941,160.304612 C82.6928941,156.607812 79.6732235,153.631153 75.9447529,153.631153 C68.0460235,153.631153 68.0460235,153.631153 68.0460235,153.631153 C47.0928,153.631153 47.0928,153.631153 47.0928,153.631153 C46.2335059,153.631153 45.3742118,153.914447 44.6557176,154.197647 L58.8608,154.197647 Z" id="Fill-64" fill="#3C3C3C"></path>
                                <path d="M74.5125647,196.22128 C73.9348706,196.22128 73.3619765,195.933214 72.7891765,195.49632 C69.9103059,192.380433 65.7545412,190.536828 61.4435765,190.536828 C57.1422118,190.536828 53.1176471,192.380433 50.2484706,195.49632 C49.3891765,196.504536 47.8112941,196.504536 46.952,195.649948 C45.9471059,194.79056 45.9471059,193.374249 46.8064,192.380433 C50.5348706,188.270739 55.8508235,185.846202 61.4435765,185.846202 C67.1867294,185.846202 72.4929882,188.270739 76.2311529,192.380433 C77.0904471,193.374249 77.0904471,194.79056 76.0855529,195.649948 C75.6583529,196.077242 75.0854588,196.22128 74.5125647,196.22128 Z" id="Fill-65" fill="#3C3C3C"></path>
                                <path d="M50.9669647,197.637581 C50.9669647,199.053892 49.8163765,200.186946 48.5298824,200.186946 C47.0928,200.186946 45.9471059,199.053892 45.9471059,197.637581 C45.9471059,196.22128 47.0928,195.073826 48.5298824,195.073826 C49.8163765,195.073826 50.9669647,196.22128 50.9669647,197.637581 Z" id="Fill-66" fill="#212121"></path>
                                <path d="M77.0904471,197.637581 C77.0904471,199.053892 75.9447529,200.186946 74.5125647,200.186946 C73.2212706,200.186946 72.0608941,199.053892 72.0608941,197.637581 C72.0608941,196.22128 73.2212706,195.073826 74.5125647,195.073826 C75.9447529,195.073826 77.0904471,196.22128 77.0904471,197.637581 Z" id="Fill-67" fill="#212121"></path>
                                <path d="M56.4237176,119.702118 C56.4237176,119.702118 55.1323294,119.562918 53.7001412,119.702118 C55.8508235,120.268612 57.7151059,122.678776 57.7151059,125.103341 C57.7151059,137.730071 57.7151059,137.730071 57.7151059,137.730071 C57.7151059,140.279435 55.9965176,142.704 53.7001412,143.126494 C55.1323294,143.270494 56.4237176,143.126494 56.4237176,143.126494 C59.1472,143.126494 61.4435765,140.706729 61.4435765,137.730071 C61.4435765,125.103341 61.4435765,125.103341 61.4435765,125.103341 C61.4435765,122.112282 59.1472,119.702118 56.4237176,119.702118 Z" id="Fill-68" fill="#3C3C3C"></path>
                                <path d="M58.72,137.730071 C58.72,140.706729 56.4237176,143.126494 53.7001412,143.126494 C53.7001412,143.126494 50.9669647,142.9872 49.3891765,142.9872 C47.9569882,142.9872 45.2334118,143.126494 45.2334118,143.126494 C42.4953412,143.126494 40.2038588,140.706729 40.2038588,137.730071 C40.2038588,125.103341 40.2038588,125.103341 40.2038588,125.103341 C40.2038588,122.112282 42.4953412,119.702118 45.2334118,119.702118 C45.2334118,119.702118 47.5248941,119.985412 49.3891765,119.985412 C51.3941647,119.985412 53.7001412,119.702118 53.7001412,119.702118 C56