ing"/>
</s:AttributeType>
<s:AttributeType name="Min" rs:number="3">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="LN" rs:number="4">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Fil" rs:number="5">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Fun" rs:number="6">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Uid" rs:number="7">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Msg" rs:number="8">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="PID" rs:number="9">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="TID" rs:number="10">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Con" rs:number="11">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Exe" rs:number="12">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Mod" rs:number="13">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Err" rs:number="14">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="MD" rs:number="15">
<s:datatype dt:type="hexBinary"/>
</s:AttributeType>
<s:AttributeType name="DT" rs:number="16">
<s:datatype dt:type="dateTime"/>
</s:AttributeType>
</s:ElementType>
</s:Schema>
<rs:data>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in PushButtonReset::WindowsRE::Config::GetCurrentWimPath (base\reset\util\src\windowsre.cpp:297): WinRE is not enabled in this configuration" PID="5336" TID="1408" Con="" Exe="C:\Windows\system32\wuauclt.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-07T18:38:20"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::CreateExecutionContext (base\diagnosis\srt\winreagent\lib\operations\executioncontext.cpp:42): Failed to get winre path" PID="5336" TID="1408" Con="" Exe="C:\Windows\system32\wuauclt.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-07T18:38:20"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::WinREServicingManager::GetInstalledWinREVersion (base\diagnosis\srt\winreagent\dll\winreservicingmanager.cpp:145): Failed to create execution context" PID="5336" TID="1408" Con="" Exe="C:\Windows\system32\wuauclt.exe" Mod="WinREAgent.dll" Err="122" MD="" DT="2023-06-07T18:38:20"/>
</rs:data>
</xml>
<xml xmlns:s="uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882"
 xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
 xmlns:rs="urn:schemas-microsoft-com:rowset"
 xmlns:z="#RowsetSchema">
<s:Schema id="RowsetSchema">
<s:ElementType name="row" content="eltOnly" rs:updatable="true">
<s:AttributeType name="Cls" rs:number="0">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Sev" rs:number="1">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Maj" rs:number="2">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Min" rs:number="3">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="LN" rs:number="4">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Fil" rs:number="5">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Fun" rs:number="6">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Uid" rs:number="7">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Msg" rs:number="8">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="PID" rs:number="9">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="TID" rs:number="10">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Con" rs:number="11">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Exe" rs:number="12">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Mod" rs:number="13">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Err" rs:number="14">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="MD" rs:number="15">
<s:datatype dt:type="hexBinary"/>
</s:AttributeType>
<s:AttributeType name="DT" rs:number="16">
<s:datatype dt:type="dateTime"/>
</s:AttributeType>
</s:ElementType>
</s:Schema>
<rs:data>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in PushButtonReset::WindowsRE::Config::GetCurrentWimPath (base\reset\util\src\windowsre.cpp:297): WinRE is not enabled in this configuration" PID="272" TID="4008" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-14T23:27:55"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::CreateExecutionContext (base\diagnosis\srt\winreagent\lib\operations\executioncontext.cpp:42): Failed to get winre path" PID="272" TID="4008" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-14T23:27:55"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::WinREServicingManager::GetInstalledWinREVersion (base\diagnosis\srt\winreagent\dll\winreservicingmanager.cpp:145): Failed to create execution context" PID="272" TID="4008" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="122" MD="" DT="2023-06-14T23:27:55"/>
</rs:data>
</xml>
<xml xmlns:s="uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882"
 xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
 xmlns:rs="urn:schemas-microsoft-com:rowset"
 xmlns:z="#RowsetSchema">
<s:Schema id="RowsetSchema">
<s:ElementType name="row" content="eltOnly" rs:updatable="true">
<s:AttributeType name="Cls" rs:number="0">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Sev" rs:number="1">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Maj" rs:number="2">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Min" rs:number="3">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="LN" rs:number="4">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Fil" rs:number="5">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Fun" rs:number="6">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Uid" rs:number="7">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Msg" rs:number="8">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="PID" rs:number="9">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="TID" rs:number="10">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Con" rs:number="11">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Exe" rs:number="12">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Mod" rs:number="13">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Err" rs:number="14">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="MD" rs:number="15">
<s:datatype dt:type="hexBinary"/>
</s:AttributeType>
<s:AttributeType name="DT" rs:number="16">
<s:datatype dt:type="dateTime"/>
</s:AttributeType>
</s:ElementType>
</s:Schema>
<rs:data>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in PushButtonReset::WindowsRE::Config::GetCurrentWimPath (base\reset\util\src\windowsre.cpp:297): WinRE is not enabled in this configuration" PID="6648" TID="9768" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-15T00:07:42"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::CreateExecutionContext (base\diagnosis\srt\winreagent\lib\operations\executioncontext.cpp:42): Failed to get winre path" PID="6648" TID="9768" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-15T00:07:42"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::WinREServicingManager::GetInstalledWinREVersion (base\diagnosis\srt\winreagent\dll\winreservicingmanager.cpp:145): Failed to create execution context" PID="6648" TID="9768" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="122" MD="" DT="2023-06-15T00:07:42"/>
</rs:data>
</xml>
<xml xmlns:s="uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882"
 xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
 xmlns:rs="urn:schemas-microsoft-com:rowset"
 xmlns:z="#RowsetSchema">
<s:Schema id="RowsetSchema">
<s:ElementType name="row" content="eltOnly" rs:updatable="true">
<s:AttributeType name="Cls" rs:number="0">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Sev" rs:number="1">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Maj" rs:number="2">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Min" rs:number="3">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="LN" rs:number="4">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Fil" rs:number="5">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Fun" rs:number="6">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Uid" rs:number="7">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Msg" rs:number="8">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="PID" rs:number="9">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="TID" rs:number="10">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="Con" rs:number="11">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Exe" rs:number="12">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Mod" rs:number="13">
<s:datatype dt:type="string"/>
</s:AttributeType>
<s:AttributeType name="Err" rs:number="14">
<s:datatype dt:type="int"/>
</s:AttributeType>
<s:AttributeType name="MD" rs:number="15">
<s:datatype dt:type="hexBinary"/>
</s:AttributeType>
<s:AttributeType name="DT" rs:number="16">
<s:datatype dt:type="dateTime"/>
</s:AttributeType>
</s:ElementType>
</s:Schema>
<rs:data>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in PushButtonReset::WindowsRE::Config::GetCurrentWimPath (base\reset\util\src\windowsre.cpp:297): WinRE is not enabled in this configuration" PID="2208" TID="1600" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-15T15:25:36"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::CreateExecutionContext (base\diagnosis\srt\winreagent\lib\operations\executioncontext.cpp:42): Failed to get winre path" PID="2208" TID="1600" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="0" MD="" DT="2023-06-15T15:25:36"/>
<z:row Cls="D" Sev="33554432" Maj="Def" Min="Def" LN="236" Fil="" Fun="PushButtonReset::Logging::TraceErr" Uid="33554432" Msg="0x80070490 in WinREAgent::WinREServicingManager::GetInstalledWinREVersion (base\diagnosis\srt\winreagent\dll\winreservicingmanager.cpp:145): Failed to create execution context" PID="2208" TID="1600" Con="" Exe="C:\Windows\system32\svchost.exe" Mod="WinREAgent.dll" Err="122" MD="" DT="2023-06-15T15:25:36"/>
</rs:data>
</xml>
<xml xmlns:s="uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882"
 xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
 xmlns:rs="urn:schemas-microsoft-com:rowset"
 xmlns:z="#RowsetSchema">
<s:Schema id="RowsetSchema"veRequire = global.nativeRequire;
  if (!module && nativeRequire) {
    const {segmentId, localId} = unpackModuleId(moduleId);
    nativeRequire(localId, segmentId);
    module = modules[moduleId];
  }

  if (!module) {
    throw unknownModuleError(moduleId);
  }

  if (module.hasError) {
    throw module.error;
  }

  if (__DEV__) {
    var Systrace = requireSystrace();
    var Refresh = requireRefresh();
  }

  // We must optimistically mark module as initialized before running the
  // factory to keep any require cycles inside the factory from causing an
  // infinite require loop.
  module.isInitialized = true;

  const {factory, dependencyMap} = module;
  if (__DEV__) {
    initializingModuleIds.push(moduleId);
  }
  try {
    if (__DEV__) {
      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists
      Systrace.beginEvent('JS_require_' + (module.verboseName || moduleId));
    }

    const moduleObject: Module = module.publicModule;

    if (__DEV__) {
      moduleObject.hot = module.hot;

      var prevRefreshReg = global.$RefreshReg$;
      var prevRefreshSig = global.$RefreshSig$;
      if (Refresh != null) {
        const RefreshRuntime = Refresh;
        global.$RefreshReg$ = (type, id) => {
          RefreshRuntime.register(type, moduleId + ' ' + id);
        };
        global.$RefreshSig$ =
          RefreshRuntime.createSignatureFunctionForTransform;
      }
    }
    moduleObject.id = moduleId;

    // keep args in sync with with defineModuleCode in
    // metro/src/Resolver/index.js
    // and metro/src/ModuleGraph/worker.js
    factory(
      global,
      metroRequire,
      metroImportDefault,
      metroImportAll,
      moduleObject,
      moduleObject.exports,
      dependencyMap,
    );

    // avoid removing factory in DEV mode as it breaks HMR
    if (!__DEV__) {
      // $FlowFixMe: This is only sound because we never access `factory` again
      module.factory = undefined;
      module.dependencyMap = undefined;
    }

    if (__DEV__) {
      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists
      Systrace.endEvent();

      if (Refresh != null) {
        registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
      }
    }

    return moduleObject.exports;
  } catch (e) {
    module.hasError = true;
    module.error = e;
    module.isInitialized = false;
    module.publicModule.exports = undefined;
    throw e;
  } finally {
    if (__DEV__) {
      if (initializingModuleIds.pop() !== moduleId) {
        throw new Error(
          'initializingModuleIds is corrupt; something is terribly wrong',
        );
      }
      global.$RefreshReg$ = prevRefreshReg;
      global.$RefreshSig$ = prevRefreshSig;
    }
  }
}

function unknownModuleError(id: ModuleID): Error {
  let message = 'Requiring unknown module "' + id + '".';
  if (__DEV__) {
    message +=
      ' If you are sure the module exists, try restarting Metro. ' +
      'You may also want to run `yarn` or `npm install`.';
  }
  return Error(message);
}

if (__DEV__) {
  // $FlowFixMe[prop-missing]
  metroRequire.Systrace = {
    beginEvent: (): void => {},
    endEvent: (): void => {},
  };
  // $FlowFixMe[prop-missing]
  metroRequire.getModules = (): ModuleList => {
    return modules;
  };

  // HOT MODULE RELOADING
  var createHotReloadingObject = function () {
    const hot: HotModuleReloadingData = {
      _acceptCallback: null,
      _disposeCallback: null,
      _didAccept: false,
      accept: (callback?: HotModuleReloadingCallback): void => {
        hot._didAccept = true;
        hot._acceptCallback = callback;
      },
      dispose: (callback?: HotModuleReloadingCallback): void => {
        hot._disposeCallback = callback;
      },
    };
    return hot;
  };

  let reactRefreshTimeout: null | TimeoutID = null;

  const metroHotUpdateModule = function (
    id: ModuleID,
    factory: FactoryFn,
    dependencyMap: DependencyMap,
    inverseDependencies: InverseDependencyMap,
  ) {
    const mod = modules[id];
    if (!mod) {
      if (factory) {
        // New modules are going to be handled by the define() method.
        return;
      }
      throw unknownModuleError(id);
    }

    if (!mod.hasError && !mod.isInitialized) {
      // The module hasn't actually been executed yet,
      // so we can always safely replace it.
      mod.factory = factory;
      mod.dependencyMap = dependencyMap;
      return;
    }

    const Refresh = requireRefresh();
    const refreshBoundaryIDs = new Set<ModuleID>();

    // In this loop, we will traverse the dependency tree upwards from the
    // changed module. Updates "bubble" up to the closest accepted parent.
    //
    // If we reach the module root and nothing along the way accepted the update,
    // we know hot reload is going to fail. In that case we return false.
    //
    // The main purpose of this loop is to figure out whether it's safe to apply
    // a hot update. It is only safe when the update was accepted somewhere
    // along the way upwards for each of its parent dependency module chains.
    //
    // We perform a topological sort because we may discover the same
    // module more than once in the list of things to re-execute, and
    // we want to execute modules before modules that depend on them.
    //
    // If we didn't have this check, we'd risk re-evaluating modules that
    // have side effects and lead to confusing and meaningless crashes.

    let didBailOut = false;
    let updatedModuleIDs;
    try {
      updatedModuleIDs = topologicalSort(
        [id], // Start with the changed module and go upwards
        pendingID => {
          const pendingModule = modules[pendingID];
          if (pendingModule == null) {
            // Nothing to do.
            return [];
          }
          const pendingHot = pendingModule.hot;
          if (pendingHot == null) {
            throw new Error(
              '[Refresh] Expected module.hot to always exist in DEV.',
            );
          }
          // A module can be accepted manually from within itself.
          let canAccept = pendingHot._didAccept;
          if (!canAccept && Refresh != null) {
            // Or React Refresh may mark it accepted based on exports.
            const isBoundary = isReactRefreshBoundary(
              Refresh,
              pendingModule.publicModule.exports,
            );
            if (isBoundary) {
              canAccept = true;
              refreshBoundaryIDs.add(pendingID);
            }
          }
          if (canAccept) {
            // Don't look at parents.
            return [];
          }
          // If we bubble through the roof, there is no way to do a hot update.
          // Bail out altogether. This is the failure case.
          const parentIDs = inverseDependencies[pendingID];
          if (parentIDs.length === 0) {
            // Reload the app because the hot reload can't succeed.
            // This should work both on web and React Native.
            performFullRefresh('No root boundary', {
              source: mod,
              failed: pendingModule,
            });
            didBailOut = true;
            return [];
          }
          // This module can't handle the update but maybe all its parents can?
          // Put them all in the queue to run the same set of checks.
          return parentIDs;
        },
        () => didBailOut, // Should we stop?
      ).reverse();
    } catch (e) {
      if (e === CYCLE_DETECTED) {
        performFullRefresh('Dependency cycle', {
          source: mod,
        });
        return;
      }
      throw e;
    }

    if (didBailOut) {
      return;
    }

    // If we reached here, it is likely that hot reload will be successful.
    // Run the actual factories.
    const seenModuleIDs = new Set<ModuleID>();
    for (let i = 0; i < updatedModuleIDs.length; i++) {
      const updatedID = updatedModuleIDs[i];
      if (seenModuleIDs.has(updatedID)) {
        continue;
      }
      seenModuleIDs.add(updatedID);

      const updatedMod = modules[updatedID];
      if (updatedMod == null) {
        throw new Error('[Refresh] Expected to find the updated module.');
      }
      const prevExports = updatedMod.publicModule.exports;
      const didError = runUpdatedModule(
        updatedID,
        updatedID === id ? factory : undefined,
        updatedID === id ? dependencyMap : undefined,
      );
      const nextExports = updatedMod.publicModule.exports;

      if (didError) {
        // The user was shown a redbox about module initialization.
        // There's nothing for us to do here until it's fixed.
        return;
      }

      if (refreshBoundaryIDs.has(updatedID)) {
        // Since we just executed the code for it, it's possible
        // that the new exports make it ineligible for being a boundary.
        const isNoLongerABoundary = !isReactRefreshBoundary(
          Refresh,
          nextExports,
        );
        // It can also become ineligible if its exports are incompatible
        // with the previous exports.
        // For example, if you add/remove/change exports, we'll want
        // to re-execute the importing modules, and force those components
        // to re-render. Similarly, if you convert a class component
        // to a function, we want to invalidate the boundary.
        const didInvalidate = shouldInvalidateReactRefreshBoundary(
          Refresh,
          prevExports,
          nextExports,
        );
        if (isNoLongerABoundary || didInvalidate) {
          // We'll be conservative. The only case in which we won't do a full
          // reload is if all parent modules are also refresh boundaries.
          // In that case we'll add them to the current queue.
          const parentIDs = inverseDependencies[updatedID];
          if (parentIDs.length === 0) {
            // Looks like we bubbled to the root. Can't recover from that.
            performFullRefresh(
              isNoLongerABoundary
                ? 'No longer a boundary'
                : 'Invalidated boundary',
              {
                source: mod,
                failed: updatedMod,
              },
            );
            return;
          }
          // Schedule all parent refresh boundaries to re-run in this loop.
          for (let j = 0; j < parentIDs.length; j++) {
            const parentID = parentIDs[j];
            const parentMod = modules[parentID];
            if (parentMod == null) {
              throw new Error('[Refresh] Expected to find parent module.');
            }
            const canAcceptParent = isReactRefreshBoundary(
              Refresh,
              parentMod.publicModule.exports,
            );
            if (canAcceptParent) {
              // All parents will have to re-run too.
              refreshBoundaryIDs.add(parentID);
              updatedModuleIDs.push(parentID);
            } else {
              performFullRefresh('Invalidated boundary', {
                source: mod,
                failed: parentMod,
              });
              return;
            }
          }
        }
      }
    }

    if (Refresh != null) {
      // Debounce a little in case there are multiple updates queued up.
      // This is also useful because __accept may be called multiple times.
      if (reactRefreshTimeout == null) {
        reactRefreshTimeout = setTimeout(() => {
          reactRefreshTimeout = null;
          // Update React components.
          Refresh.performReactRefresh();
        }, 30);
      }
    }
  };

  const topologicalSort = function <T>(
    roots: Array<T>,
    getEdges: T => Array<T>,
    earlyStop: T => boolean,
  ): Array<T> {
    const result = [];
    const visited = new Set<mixed>();
    const stack = new Set<mixed>();
    function traverseDependentNodes(node: T): void {
      if (stack.has(node)) {
        throw CYCLE_DETECTED;
      }
      if (visited.has(node)) {
        return;
      }
      visited.add(node);
      stack.add(node);
      const dependentNodes = getEdges(node);
      if (earlyStop(node)) {
        stack.delete(node);
        return;
      }
      dependentNodes.forEach(dependent => {
        traverseDependentNodes(dependent);
      });
      stack.delete(node);
      result.push(node);
    }
    roots.forEach(root => {
      traverseDependentNodes(root);
    });
    return result;
  };

  const runUpdatedModule = function (
    id: ModuleID,
    factory?: FactoryFn,
    dependencyMap?: DependencyMap,
  ): boolean {
    const mod = modules[id];
    if (mod == null) {
      throw new Error('[Refresh] Expected to find the module.');
    }

    const {hot} = mod;
    if (!hot) {
      throw new Error('[Refresh] Expected module.hot to always exist in DEV.');
    }

    if (hot._disposeCallback) {
      try {
        hot._disposeCallback();
      } catch (error) {
        console.error(
          `Error while calling dispose handler for module ${id}: `,
          error,
        );
      }
    }

    if (factory) {
      mod.factory = factory;
    }
    if (dependencyMap) {
      mod.dependencyMap = dependencyMap;
    }
    mod.hasError = false;
    mod.error = undefined;
    mod.importedAll = EMPTY;
    mod.importedDefault = EMPTY;
    mod.isInitialized = false;
    const prevExports = mod.publicModule.exports;
    mod.publicModule.exports = {};
    hot._didAccept = false;
    hot._acceptCallback = null;
    hot._disposeCallback = null;
    metroRequire(id);

    if (mod.hasError) {
      // This error has already been reported via a redbox.
      // We know it's likely a typo or some mistake that was just introduced.
      // Our goal now is to keep the rest of the application working so that by
      // the time user fixes the error, the app isn't completely destroyed
      // underneath the redbox. So we'll revert the module object to the last
      // successful export and stop propagating this update.
      mod.hasError = false;
      mod.isInitialized = true;
      mod.error = null;
      mod.publicModule.exports = prevExports;
      // We errored. Stop the update.
      return true;
    }

    if (hot._acceptCallback) {
      try {
        hot._acceptCallback();
      } catch (error) {
        console.error(
          `Error while calling accept handler for module ${id}: `,
          error,
        );
      }
    }
    // No error.
    return false;
  };

  const performFullRefresh = (
    reason: string,
    modules: $ReadOnly<{
      source?: ModuleDefinition,
      failed?: ModuleDefinition,
    }>,
  ) => {
    /* global window */
    if (
      typeof window !== 'undefined' &&
      window.location != null &&
      typeof window.location.reload === 'function'
    ) {
      window.location.reload();
    } else {
      const Refresh = requireRefresh();
      if (Refresh != null) {
        const sourceName = modules.source?.verboseName ?? 'unknown';
        const failedName = modules.failed?.verboseName ?? 'unknown';
        Refresh.performFullRefresh(
          `Fast Refresh - ${reason} <${sourceName}> <${failedName}>`,
        );
      } else {
        console.warn('Could not reload the application after an edit.');
      }
    }
  };

  // Modules that only export components become React Refresh boundaries.
  var isReactRefreshBoundary = function (
    Refresh: any,
    moduleExports: Exports,
  ): boolean {
    if (Refresh.isLikelyComponentType(moduleExports)) {
      return true;
    }
    if (moduleExports == null || typeof moduleExports !== 'object') {
      // Exit if we can't iterate over exports.
      return false;
    }
    let hasExports = false;
    let areAllExportsComponents = true;
    for (const key in moduleExports) {
      hasExports = true;
      if (key === '__esModule') {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor<any>(moduleExports, key);
      if (desc && desc.get) {
        // Don't invoke getters as they may have side effects.
        return false;
      }
      const exportValue = moduleExports[key];
      if (!Refresh.isLikelyComponentType(exportValue)) {
        areAllExportsComponents = false;
      }
    }
    return hasExports && areAllExportsComponents;
  };

  var shouldInvalidateReactRefreshBoundary = (
    Refresh: any,
    prevExports: Exports,
    nextExports: Exports,
  ) => {
    const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
    const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);
    if (prevSignature.length !== nextSignature.length) {
      return true;
    }
    for (let i = 0; i < nextSignature.length; i++) {
      if (prevSignature[i] !== nextSignature[i]) {
        return true;
      }
    }
    return false;
  };

  // When this signature changes, it's unsafe to stop at this refresh boundary.
  var getRefreshBoundarySignature = (
    Refresh: any,
    moduleExports: Exports,
  ): Array<mixed> => {
    const signature = [];
    signature.push(Refresh.getFamilyByType(moduleExports));
    if (moduleExports == null || typeof moduleExports !== 'object') {
      // Exit if we can't iterate over exports.
      // (This is important for legacy environments.)
      return signature;
    }
    for (const key in moduleExports) {
      if (key === '__esModule') {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor<any>(moduleExports, key);
      if (desc && desc.get) {
        continue;
      }
      const exportValue = moduleExports[key];
      signature.push(key);
      signature.push(Refresh.getFamilyByType(exportValue));
    }
    return signature;
  };

  var registerExportsForReactRefresh = (
    Refresh: any,
    moduleExports: Exports,
    moduleID: ModuleID,
  ) => {
    Refresh.register(moduleExports, moduleID + ' %exports%');
    if (moduleExports == null || typeof moduleExports !== 'object') {
      // Exit if we can't iterate over exports.
      // (This is important for legacy environments.)
      return;
    }
    for (const key in moduleExports) {
      const desc = Object.getOwnPropertyDescriptor<any>(moduleExports, key);
      if (desc && desc.get) {
        // Don't invoke getters as they may have side effects.
        continue;
      }
      const exportValue = moduleExports[key];
      const typeID = moduleID + ' %exports% ' + key;
      Refresh.register(exportValue, typeID);
    }
  };

  global.__accept = metroHotUpdateModule;
}

if (__DEV__) {
  // The metro require polyfill can not have module dependencies.
  // The Systrace and ReactRefresh dependencies are, therefore, made publicly
  // available. Ideally, the dependency would be inversed in a way that
  // Systrace / ReactRefresh could integrate into Metro rather than
  // having to make them publicly available.

  var requireSystrace = function requireSystrace() {
    return (
      // $FlowFixMe[prop-missing]
      global[__METRO_GLOBAL_PREFIX__ + '__SYSTRACE'] || metroRequire.Systrace
    );
  };

  var requireRefresh = function requireRefresh() {
    return (
      // $FlowFixMe[prop-missing]
      global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh'] || metroRequire.Refresh
    );
  };
}
