az alkalmaz√°s.ÃLek√©rdezi vagy be√°ll√≠tja a csoportok √©lei √©s a NavBarControl √©lei k√∂z√∂tti v√≠zszintes beh√∫z√°s (k√©ppontokban kifejezett) m√©rt√©k√©t, ha valamelyik b√∂ng√©sz≈ën√©zetet haszn√°lja az alkalmaz√°s.®Lek√©rdezi vagy be√°ll√≠tja, hogy a csoportok kibont√≥gombjai l√°that√≥k legyenek-e a csoportfejl√©cekben (amikor a b√∂ng√©sz≈ës√°vn√©zetek valamelyik√©t haszn√°lj√°k).ÜLek√©rdezi vagy be√°ll√≠tja, hogy az Int√©z≈ë s√°v n√©zet√©ben az utols√≥ csoport megny√∫ljon-e, kit√∂ltve a NavBarControl vez√©rl≈ët.6Lehet≈ëv√© teszi a tippek dinamikus testre szab√°s√°t.@Meghat√°rozza a csoportok h√°tterek√©nt megjelen√≠tend≈ë k√©pet.=K√∂zvetlen√ºl egy csoport √∂sszez√°r√°s√°t k√∂vet≈ëen indul. :Akkor k√∂vetkezik be, ha egy csoport √∂ssze fog z√°r√≥dni.8K√∂zvetlen√ºl egy csoport kibont√°s√°t k√∂vet≈ëen indul.4Akkor k√∂vetkezik be, ha egy csoport ki lesz bontva.QLek√©rdezi a NavBarControl csoportjait reprezent√°l√≥ objektumok gy≈±jtem√©ny√©t.fLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy a csoportc√≠msz√∂vegek l√°that√≥k-e.∏Lek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza azt a mutat√≥t√≠pust, amelyet akkor haszn√°l az alkalmaz√°s, amikor az eg√©rmutat√≥t egy csoportc√≠msz√∂veg f√∂l√© h√∫zz√°k.∏Lek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza azt a mutat√≥t√≠pust, amelyet akkor haszn√°l az alkalmaz√°s, amikor az eg√©rmutat√≥t egy csoportc√≠msz√∂veg f√∂l√© h√∫zz√°k.VAkkor indul, amikor az eg√©rmutat√≥ el√©ri a csatol√°s ter√ºlet√©t, vagy elhagyja azt.PLek√©rdezi a NavBarControl vez√©rl≈ëben megjelen√≠tett t√©telek gy≈±jtem√©ny√©t.rLek√©rdez vagy be√°ll√≠t egy objektumot, amely a NavBarControl elemben haszn√°lt nagy k√©pek forr√°s√°ul szolg√°l.∫Azut√°n k√∂vetkezik be, hogy egy elrendez√©s verzi√≥ja nem egyezik meg az adatfolyamb√≥l, xml-f√°jlb√≥l vagy rendszerle√≠r√≥ adatb√°zisb√≥l bet√∂lt√∂tt aktu√°lis elrendez√©si verzi√≥val.FK√∂zvetlen√ºl egy csatol√°sra t√∂rt√©n≈ë kattint√°st k√∂vet≈ëen indul.qLek√©rdezi vagy be√°ll√≠tja a csoporton bel√ºli szomsz√©dos csatol√°sok k√∂z√∂tti, k√©ppontokban m√©rt t√©rk√∂zt.:K√∂zvetlen√ºl egy csatol√°s lenyom√°s√°t k√∂vet≈ëen indul.ºLek√©rdezi vagy be√°ll√≠tja, hogy enged√©lyezve van-e a hivatkoz√°s kijel√∂l√©se, illetve hogy egyszerre mindegyik csoport, vagy csak egy csoport tartalmazhatja-e a kijel√∂lt hivatkoz√°st.zHozz√°f√©r√©st biztos√≠t azokhoz a be√°ll√≠t√°sokhoz, amelyek a NavBarControl megjelen√©s√©t √©s viselked√©s√©t vez√©rlik.yLek√©rdez vagy be√°ll√≠t egy objektumot, amely a vez√©rl≈ë felugr√≥ men√ºinek megjelen√©s√©t √©s viselked√©s√©t vez√©rli.HK√∂zvetlen√ºl egy csatol√°s h√∫z√°s ut√°ni lerak√°s√°t k√∂vet≈ëen indul.GAmikor elh√∫znak egy csatol√°st, √©s az letehet≈ë, ism√©telten elindul.oAkkor k√∂vetkezik be, amikor kibontj√°k a navig√°ci√≥s ablak n√©zet√©n bel√ºli kis m√©ret≈± NavBarGroup elemet.‘Lehet≈ëv√© teszi egy bet≈±t√≠pus csoportra t√∂rt√©n≈ë alkalmaz√°s√°t, miut√°n a v√©gfelhaszn√°l√≥ megv√°ltoztatta a bet≈±t√≠pus-be√°ll√≠t√°sokat a navig√°ci√≥s ablak Be√°ll√≠t√°sok p√°rbesz√©dpanel√©n kereszt√ºl.”Lehet≈ëv√© teszi annak meghat√°roz√°s√°t, hogy a v√©gfelhaszn√°l√≥ szerkesztheti-e az egyes csoportokra vonatkoz√≥ bet≈±t√≠pus-be√°ll√≠t√°sokat a navig√°ci√≥s ablak Be√°ll√≠t√°sok p√°rbesz√©dpanel√©n kereszt√ºl.nAkkor indul, ha a navig√°ci√≥s ablak Be√°ll√≠t√°sok p√°rbesz√©dpanel√©n l√©v≈ë Alaphelyzet gombra kattintanak.uA NavBarControl kibont√°si √°llapot√°nak m√≥dos√≠t√°s√°t k√∂vet≈ëen indul (a NavigationPane sz√≠nez√©si st√≠lusn√°l).∂Lek√©rdezi vagy be√°ll√≠tja az akt√≠v csoporthoz tartoz√≥ √ºgyf√©lter√ºlet alap√©rtelmezett minim√°lis magass√°g√°t, amikor a ‚ÄûNavigationPane‚Äù n√©zetet haszn√°lja az alkalmaz√°s. Lek√©rdezi azoknak a csoportoknak a maxim√°lis sz√°m√°t, amelyek gombjait megjelen√≠ti az alkalmaz√°s a NavBarControl vez√©rl≈ën bel√ºl, amikor a ‚ÄûNavigationPane‚Äù n√©zetet haszn√°lja az alkalmaz√°s.vLek√©rdezi vagy be√°ll√≠tja, hogy a T√∫lcsordul√°s panelen l√©v≈ë csoportokat kis vagy nagy ikonok reprezent√°lj√°k-e.ÁBe√°ll√≠t√°sokat tartalmaz, amelyek azt vez√©rlik, hogy a NavBarControl elem elrendez√©s√©t hogyan t√°rolja az alkalmaz√°s egy adatfolyamban, xml-f√°jlban vagy a rendszerle√≠r√≥ adatb√°zisban, illetve hogyan √°ll√≠tja vissza onnan.ØBe√°ll√≠t√°sokat tartalmaz, amelyek a NavBarControl megjelen√©s√©t √©s viselked√©s√©t hat√°rozz√°k meg, amikor a NavigationPane sz√≠nez√©si st√≠lust haszn√°lja az alkalmaz√°s.PLek√©rdezi vagy be√°ll√≠tja a NavBarControl sz√≠nez√©si st√≠lus√°nak fajt√°j√°t.ZLek√©rdezi vagy be√°ll√≠tja a NavBarControl elemre alkalmazott sz√≠nez√©si st√≠lus nev√©t.vLek√©rdezi vagy be√°ll√≠tja, hogy a csatol√°st kiv√°lassza-e az alkalmaz√°s az MouseDown vagy MouseUp esem√©ny sor√°n.>K√∂zvetlen√ºl egy csatol√°s kiv√°laszt√°s√°t k√∂vet≈ëen indul.ªLek√©rdezi vagy be√°ll√≠tja azt az √©rt√©ket, amely megadja a k√©pek megjelen√≠t√©si m√©ret√©nek meghat√°roz√°si m√≥dj√°t, amikor a k√©pek a SharedImageCollection forr√°sb√≥l sz√°rmaznak.dLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy a csoport tippjei megjelenjenek-e.£Lek√©rdezi vagy be√°ll√≠tja azt az id≈ëtartamot, amely az eg√©rmutat√≥ egy elem feletti tart√≥zkod√°sa √©s a hozz√° tartoz√≥ tipp megjelen√≠t√©se k√∂z√∂tt eltelik.fLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy a csatol√°s tippjei megjelenjenek-e.¶Lek√©rdezi vagy be√°ll√≠tja a vez√©rl≈ë g√∂rget√©si m√≥dj√°t, amikor a fel√ºleteket haszn√°l√≥ b√∂ng√©sz≈ës√°vn√©zet sz√≠nez√©si s√©m√°j√°t haszn√°lja az alkalmaz√°s.qLek√©rdez vagy be√°ll√≠t egy objektumot, amely a NavBarControl elemben haszn√°lt kis k√©pek forr√°s√°ul szolg√°l.ìLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely megmutatja, hogy egy felhaszn√°l√≥ kiemelheti-e az adott vez√©rl≈ët a TAB billenty≈± haszn√°lat√°val.∫Lek√©rdezi vagy be√°ll√≠tja a eszk√∂ztippvez√©rl≈ë azon √∂sszetev≈ëj√©t, amelyik az XtraNavBar vez√©rl≈ë √°ltal megjelen√≠tett tippek megjelen√©s√©t, helyzet√©t √©s tartalm√°t vez√©rli. ZLek√©rdezi a csoport h√°tter√©nek sz√≠nez√©s√©hez haszn√°lt megjelen√©si be√°ll√≠t√°sokat.6Lek√©rdezi vagy be√°ll√≠tja a csoport h√°tt√©rk√©p√©t.HEgy csoporthoz tartoz√≥ √ºgyf√©l magass√°g√°nak kisz√°m√≠t√°sakor indul.ÂLek√©rdezi vagy be√°ll√≠tja a NavBarControl vez√©rl≈ëbe √°gyazott vez√©rl≈ët, ha a navig√°ci√≥s s√°v a Navig√°ci√≥s ablak n√©zet seg√≠ts√©g√©vel van befestve, az aktu√°lis csoport akt√≠v √©s a navig√°ci√≥s s√°v √∂ssze van z√°rva.MLek√©rdezi azt a csoportot, amelyhez az aktu√°lis vez√©rl≈ët√°rol√≥ tartozik.ìLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely megmutatja, hogy egy felhaszn√°l√≥ kiemelheti-e az adott vez√©rl≈ët a TAB billenty≈± haszn√°lat√°val.•Lek√©rdezi vagy be√°ll√≠tja azoknak a z√°szl√≥knak a be√°ll√≠t√°s√°t, amelyek a csoport viselked√©s√©t vez√©rlik a csatol√°sok elh√∫z√°si m≈±veletei szempontj√°b√≥l._Lek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy a csoport ki legyen-e bontva.rLek√©rdezi vagy be√°ll√≠tja, hogy nagy vagy kis k√©peket jelen√≠tsen-e meg az alkalmaz√°s a csoportc√≠msz√∂vegben.ILek√©rdezi vagy be√°ll√≠tja a csoport √ºgyf√©lter√ºlet√©nek magass√°g√°t.≥Lek√©rdezi vagy be√°ll√≠tja az aktu√°lis csoportban a hivatkoz√°sok megjelen√≠t√©s√©nek m√≥dj√°t, illetve azt, hogy megjelenjen-e egy felhaszn√°l√≥i vez√©rl≈ë a csoporton bel√ºl. †Lek√©rdezi vagy be√°ll√≠tja, hogy a csoport gombja megjelenjen-e a NavBarControl als√≥ r√©sz√©n, amikor ‚ÄûNavigationPane‚Äù n√©zetet haszn√°lja az alkalmaz√°s.lLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza a csoport kiv√°lasztott csatol√°s√°nak index√©t.\Lek√©rdezi vagy be√°ll√≠tja az aktu√°lis csoport tetej√©n megjelen√≠tett csatol√°s index√©t.›Lek√©rdezi vagy be√°ll√≠tja, hogy az aktu√°lis NavBarItem √∂sszes hivatkoz√°s√°n√°l enged√©lyezve van-e az automatikus kijel√∂l√©s. Ez a tulajdons√°g a LinkSelectionModeType.OneInGroupAndAllowAutoSelect m√≥dban hat√°lyos.{Lek√©rdezi a letiltott t√©telek csatol√°s√°nak vagy csatol√°sainak sz√≠nez√©s√©hez haszn√°lt megjelen√©si be√°ll√≠t√°sokat.[Lek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy egy t√©tel elh√∫zhat√≥-e.yLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy egy t√©tel ad-e v√°laszt a felhaszn√°l√≥i m≈±veletekre.ÖLek√©rdezi vagy be√°ll√≠tja, hogy az aktu√°lis csatol√°sn√°l enged√©lyezve van-e az automatikus kijel√∂l√©s funkci√≥. Ez a tulajdons√°g a Navig√°ci√≥s ablak √©s az Oldals√°v n√©zetek LinkSelectionModeType.OneInGroupAndAllowAutoSelect m√≥dj√°ban van √©rv√©nyben.&Lek√©rdezi a csatol√°s c√≠msz√∂veg√©t.8K√∂zvetlen√ºl egy t√©telre kattint√°st k√∂vet≈ëen indul.`Lek√©rdez egy objektumot, amely azt a csoportot reprezent√°lja, amelynek megfelel egy csatol√°s.\Lek√©rdez egy objektumot, amely azt a t√©telt reprezent√°lja, amelynek megfelel a csatol√°s.9A csatol√°s tulajdons√°gainak megv√°ltoztat√°sakor indul.?A csatol√°shoz tartoz√≥ NavBarControl elemet adja eredm√©ny√ºl.HK√∂zvetlen√ºl azut√°n indul, hogy a felhaszn√°l√≥ lenyomott egy t√©telt.ZLek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza, hogy a csatol√°s l√°that√≥-e.XK√∂zvetlen√ºl a t√©telcsatol√°s l√°that√≥s√°g√°nak megv√°ltoztat√°s√°t k√∂vet≈ëen indul.‘Lek√©rdezi vagy be√°ll√≠tja, hogy a t√©tel megjelen√©si be√°ll√≠t√°sait is t√°rolja-e az alkalmaz√°s az elrendez√©s ment√©sekor, √©s vissza√°ll√≠tja-e az elrendez√©s t√°rhelyr≈ël t√∂rt√©n≈ë vissza√°ll√≠t√°sakor. rLek√©rdezi vagy be√°ll√≠tja, hogy az aktu√°lis NavElement ikonj√°t ezen t√©tel el≈ët√©rsz√≠n√©re kell-e befesteni.KLek√©rdezi az elem sz√≠nez√©s√©hez haszn√°lt megjelen√©si be√°ll√≠t√°sokat.~Lek√©rdezi az aktu√°lis elem sz√≠nez√©s√©hez haszn√°lt megjelen√©si be√°ll√≠t√°sokat, amikor az azonnali k√∂vet√©s alatt √°ll.TLek√©rdezi a lenyomott elem sz√≠nez√©s√©hez haszn√°lt megjelen√©si be√°ll√≠t√°sokat.3Lek√©rdezi vagy be√°ll√≠tja az elem c√≠msz√∂veg√©t.3Lek√©rdezi vagy be√°ll√≠tja az elem tippsz√∂veg√©t.ÆLek√©rdezi vagy be√°ll√≠tja az aktu√°lis NavElement elemben megjelen√≠tett DX k√©pgal√©ria k√©p√©nek egys√©ges er≈ëforr√°s-azonos√≠t√≥j√°t. Az adott k√©p egy bizonyos verzi√≥ja automatikusan kiv√°laszt√°sra ker√ºl az alkalmaz√°s kontextusa (az aktu√°lis fel√ºlet √©s a sz√ºks√©ges k√©pm√©ret) alapj√°n.:Meghat√°rozza az elemen bel√ºl megjelen√≠tett nagy k√©pet.]A forr√°s-k√©pgy≈±jtem√©nybeli indexe alapj√°n meghat√°rozza az elemhez tartoz√≥ nagy k√©pet.YLek√©rdezi vagy be√°ll√≠tja az aktu√°lis NavElement elemhez tartoz√≥ nagy k√©p m√©ret√©t.9Meghat√°rozza az elemen bel√ºl megjelen√≠tett kis k√©pet.\A forr√°s-k√©pgy≈±jtem√©nybeli indexe alapj√°n meghat√°rozza az elemhez tartoz√≥ kis k√©pet.XLek√©rdezi vagy be√°ll√≠tja az aktu√°lis NavElement elemhez tartoz√≥ kis k√©p m√©ret√©t.QLek√©rdez vagy be√°ll√≠t egy szupereszk√∂ztippet az aktu√°lis NavElement elemhez.<Lek√©rdezi vagy be√°ll√≠tja az elemhez t√°rs√≠tott adatokat.ULek√©rdez vagy be√°ll√≠t egy √©rt√©ket, amely meghat√°rozza az elem l√°that√≥s√°g√°t.<Lek√©rdezi a gy≈±jtem√©ny egy t√©tel√©t annak neve alapj√°n.<Lek√©rdezi a gy≈±jtem√©ny egy t√©tel√©t annak neve alapj√°n.AAz indexe alapj√°n lek√©rdezi a gy≈±jtem√©ny egy adott t√©tel√©t.=Az indexe alapj√°n lek√©rdezi a gy≈±jtem√©ny adott t√©tel√©t.€Lek√©rdezi vagy be√°ll√≠tja, hogy a v√©gfelhaszn√°l√≥k megnyithatj√°k-e a navig√°ci√≥s ablak Be√°ll√≠t√°sok p√°rbesz√©dpanel√©t a csoportok sorrendj√©nek √©s a t√©telek bet≈±t√≠pus-be√°ll√≠t√°s√°nak testre szab√°s√°hoz.tLek√©rdezi vagy be√°ll√≠tja az anim√°ci√≥s k√©pkock√°k sz√°m√°t, amikor a vez√©rl≈ët kibontj√°k vagy √∂sszez√°rj√°k.…Lek√©rdezi vagy be√°ll√≠tja a NavBarControl vez√©rl≈ëbe √°gyazott vez√©rl≈ët, ha a navig√°ci√≥s s√°vot a Navig√°ci√≥s ablak n√©zet seg√≠ts√©g√©vel festett√©k be √©s a navig√°ci√≥s s√°v √∂sszez√°r√≥dik.[Lek√©rdezi vagy be√°ll√≠tja a vez√©rl≈ë sz√©less√©g√©t, amikor √∂sszez√°rt √°llapotban van.ÉLek√©rdezi vagy be√°ll√≠tja a kibont√°si gombhoz tartoz√≥ ny√≠l ir√°ny√°t, √©s a vez√©rl≈ë √∂sszez√°r√°si/kibont√°si ir√°ny√°t is. MLek√©rdezi vagy be√°ll√≠tja a vez√©rl≈ë sz√©less√©g√©t kibontott √°llapotban.wLek√©rdezi vagy be√°ll√≠tja annak a keretnek a m√©ret√©t, amelybe egy kibontott csoport fejl√©c√©nek k√©pe illeszkedik.≈Lek√©rdezi vagy be√°ll√≠tja annak a felugr√≥ ≈±rlapnak a maxim√°lis sz√©less√©g√©t, amely akkor jelenik meg, ha r√°kattint az akt√≠v NavBarGroup csoportra az √∂sszez√°rt NavBarControl vez√©rl≈ëben.ãLek√©rdezi vagy be√°ll√≠tja a NavBarControl kibont√°si √°llapot√°t, amikor a NavigationPane sz√≠nez√©si st√≠lust haszn√°lja az alkalmaz√°s.8Lek√©rdezi vagy be√°ll√≠tja a felugr√≥ ≈±rlap m√©ret√©t.êLek√©rdezi vagy be√°ll√≠tja, hogy a kibont√°s gombja l√°that√≥ legyen-e, amikor a NavigationPane sz√≠nez√©si st√≠lust haszn√°lja az alkalmaz√°s.gLek√©rdezi vagy be√°ll√≠tja, hogy az akt√≠v csoport k√©pe megjelenik-e a NavBarControl elem fejl√©c√©n.hLek√©rdezi vagy be√°ll√≠tja, hogy megjelenjen-e az akt√≠v csoport felirata a NavBarControl fejl√©c√©ben.ÖLek√©rdezi vagy be√°ll√≠tja a Navig√°ci√≥s ablakt√°bla T√∫lcsordul√°s panelj√©n megjelen√≠tett t√∫lcsordul√°si gomb l√°that√≥s√°g√°t.XLek√©rdezi vagy be√°ll√≠tja, hogy a T√∫lcsordul√°s panelt megjelen√≠ti-e az alkalmaz√°s.\Lek√©rdezi vagy be√°ll√≠tja, hogy a navig√°ci√≥s ablakt√°bla feloszt√≥ja l√°that√≥ legyen-e.¥   Œ Ôæ   ë   lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet           PADPADP¥   √  Œ Ôæ   ë   lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADP…]üã·≈± )O…xtæ‘∏˛µËÀw∏Óà∂”Æ¬9›¶∑YAo-Üü{G   †   ı  H  ü  H      Ô   û  Ú  O  •  BN a v B a r S t r i n g I d . N a v P a n e C h e v r o n H i n t     TN a v B a r S t r i n g I d . N a v P a n e M e n u A d d R e m o v e B u t t o n s    JN a v B a r S t r i n g I d . N a v P a n e M e n u P a n e O p t i o n s C   TN a v B a r S t r i n g I d . N a v P a n e M e n u S h o w F e w e r B u t t o n s l   RN a v B a r S t r i n g I d . N a v P a n e M e n u S h o w M o r e B u t t o n s å   NN a v B a r S t r i n g I d . N a v P a n e O p t i o n s F o r m C a n c e l ™   XN a v B a r S t r i n g I d . N a v P a n e O p t i o n s F o r m D e s c r i p t i o n ≤   JN a v B a r S t r i n g I d . N a v P a n e O p t i o n s F o r m F o n t ›   RN a v B a r S t r i n g I d . N a v P a n e O p t i o n s F o r m M o v e D o w n Í   NN a v B a r S t r i n g I d . N a v P a n e O p t i o n s F o r m M o v e U p ˝   LN a v B a r S t r i n g I d . N a v P a n e O p t i o n s F o r m R e s e t   Gombok konfigur√°l√°sa)&Gombok hozz√°ad√°sa vagy elt√°vol√≠t√°sa'A na&vig√°ci√≥s ablak be√°ll√≠t√°sai...&Kevesebb gomb megjelen√≠t√©se&T√∂bb g√∂mb megjelen√≠t√©seM√©gse)Gombok megjelen√≠t√©se ebben a sorrendbenBet≈±t√≠pusMozgat√°s lefel√©Mozgat√°s felfel√©AlaphelyzetÓ   Œ Ôæ   ë   lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADP‘™ö    ’   $ t h i s . T e x t     Tulajdons√°gszerkeszt≈ë∏ARbdA’˜0n„˙]ë‘îHxí»0B‘ÀQl*ä‚·.ûè¶ê!vfÀ5ÎÃØ)f ó˚à¸S[»iç m°èd,ïAQ«8£÷∆yd¢∑o$îÀ'aE 4[∆d$Ÿ>’H&Õ Ï%Fö´Fkv~°úó>[wâ9  BSJB         v4.0.30319     l   0  #~  ú  0  #Strings    Ã     #US ‘     #GUID   ‰  L  #Blob           	   ˙%3                                   / E  L r  Ç õ 
 ≠ —  ‡ Ù     8 Iõ  dõ  ù Ω8 ﬂõ  ¸ù õ  5N hõ  áõ  ¢õ  øõ  ÷õ  Ôõ            	      !  ) ! 9  A  I  Q  Y  a  i ' q  y  Å  â  ë  ô  °  ©  .  Œ .  ‘ .  Ÿ . # ‘ . + ﬂ . 3 Ë . ; Ÿ . C ˆ . K . S %. [ 0. c >. k G. s x. { Ÿ . É ﬁ. ã ˆ . ì . õ -. £ Ä           , 4            
              
             7  ea     g  b     ù  ‰g     –       <Module> mscorlib DevExpress.XtraNavBar.v16.1 CLSCompliantAttribute System AllowPartiallyTrustedCallersAttribute System.Security AssemblyKeyNameAttribute System.Reflection BitmapSuffixInSameAssemblyAttribute System.Drawing DebuggableAttribute System.Diagnostics DebuggingModes SatelliteContractVersionAttribute System.Resources AssemblyDelaySignAttribute AssemblyTrademarkAttribute RuntimeCompatibilityAttribute System.Runtime.CompilerServices NeutralResourcesLanguageAttribute AssemblyFileVersionAttribute CompilationRelaxationsAttribute AssemblyKeyFileAttribute TargetFrameworkAttribute System.Runtime.Versioning AssemblyConfigurationAttribute AssemblyCopyrightAttribute AssemblyDescriptionAttribute AssemblyTitleAttribute AssemblyCompanyAttribute AssemblyProductAttribute .ctor DevExpress.XtraNavBar.v16.1.resources hu DevExpress.XtraNavBar.Descriptions.hu.resources DevExpress.XtraNavBar.NavPaneOptionsForm.hu.resources DevExpress.XtraNavBar.LocalizationRes.hu.resources DevExpress.Utils.Design.BaseDesignerForm.hu.resources DevExpress.XtraNavBar.v16.1.resources.dll        ëŒ¬©Ö}úAàø∆(ºiÉ ∑z\V4‡â∏çT◊ ‰ö      Ä† $  Ä  î      $  RSA1     ﬂÕå≠¬›$ßÕLÈ\Júé|±‹-fQ UkK√Tï˝€+÷Ó– VHv)Z"[¢©to=>T|œ[&¨√˘n≤°:ƒgQ$ó™y é2ÚB˝MS…Z6ÂﬁâsÑ®ıYVn8ÈhBdà¥™MYÂü8‹Û˚ÃÚ]ô
±ú'›¬                 16.1.0.0   
XtraNavBar    TWrapNonExceptionThrows
 en-US   16.1.5.0        0 +..\..\..\..\..\DevExpress.Key\StrongKey.snk  e ).NETFramework,Version=v4.0,Profile=Client TFrameworkDisplayName.NET Framework 4 Client Profile3 .Copyright (c) 2000-2016 Developer Express Inc.   DevExpress.XtraNavBar   Developer Express Inc.      ì          ì                          ì                _CorDllMain mscoree.dll     ˇ%  @                                                                                                                                                                                                                 9*?E           Ä    9*?E         0  Ä    9*?E         H   X†  0          04   V S _ V E R S I O N _ I N F O     ΩÔ˛             ?                         D    V a r F i l e I n f o     $    T r a n s l a t i o n     ∞ê   S t r i n g F i l e I n f o   l   0 4 0 e 0 4 b 0   0   C o m m e n t s   X t r a N a v B a r     P   C o m p a n y N a m e     D e v e l o p e r   E x p r e s s   I n c .     T   F i l e D e s c r i p t i o n     D e v E x p r e s s . X t r a N a v B a r   4 	  F i l e V e r s i o n     1 6 . 1 . 5 . 0     `    I n t e r n a l N a m e   D e v E x p r e s s . X t r a N a v B a r . v 1 6 . 1 . d l l   Ñ /  L e g a l C o p y r i g h t   C o p y r i g h t   ( c )   2 0 0 0 - 2 0 1 6   D e v e l o p e r   E x p r e s s   I n c .     @   L e g a l T r a d e m a r k s     X t r a N a v B a r     h    O r i g i n a l F i l e n a m e   D e v E x p r e s s . X t r a N a v B a r . v 1 6 . 1 . d l l   L   P r o d u c t N a m e     D e v E x p r e s s . X t r a N a v B a r   8 	  P r o d u c t V e r s i o n   1 6 . 1 . 5 . 0     < 	  A s s e m b l y   V e r s i o n   1 6 . 1 . 5 . 0                                                                                                                                                                                                                                                                                                                                                                                              ê     03                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          0Ç 	*ÜHÜ˜†ÇÒ0ÇÌ10	`ÜHe 0x
+Ç7†j0h03
+Ç70% † ¢Ä < < < O b s o l e t e > > >010	`ÜHe  [dl∂1AË<MúÃ“E©≤(òΩﬂèsá‘∆6°Ov†Ç
R0Ç0ÇÎ†vr¥&“Í~dS•É8Ññ0	*ÜHÜ˜ 0ÅÑ10	UUS10U
Symantec Corporation10USymantec Trust Network1503U,Symantec Class 3 SHA256 Code Signing CA - G20160808000000Z170902235959Z0Åà10	UUS10U
California10U
San Rafael10U
Autodesk, Inc10UDesign Solutions Group10U: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        prependListener(event: 'secureConnect', listener: () => void): this;
        prependListener(event: 'session', listener: (session: Buffer) => void): this;
        prependListener(event: 'keylog', listener: (line: Buffer) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        prependOnceListener(event: 'secureConnect', listener: () => void): this;
        prependOnceListener(event: 'session', listener: (session: Buffer) => void): this;
        prependOnceListener(event: 'keylog', listener: (line: Buffer) => void): this;
    }
    interface CommonConnectionOptions {
        /**
         * An optional TLS context object from tls.createSecureContext()
         */
        secureContext?: SecureContext | undefined;
        /**
         * When enabled, TLS packet trace information is written to `stderr`. This can be
         * used to debug TLS connection problems.
         * @default false
         */
        enableTrace?: boolean | undefined;
        /**
         * If true the server will request a certificate from clients that
         * connect and attempt to verify that certificate. Defaults to
         * false.
         */
        requestCert?: boolean | undefined;
        /**
         * An array of strings or a Buffer naming possible ALPN protocols.
         * (Protocols should be ordered by their priority.)
         */
        ALPNProtocols?: string[] | Uint8Array[] | Uint8Array | undefined;
        /**
         * SNICallback(servername, cb) <Function> A function that will be
         * called if the client supports SNI TLS extension. Two arguments
         * will be passed when called: servername and cb. SNICallback should
         * invoke cb(null, ctx), where ctx is a SecureContext instance.
         * (tls.createSecureContext(...) can be used to get a proper
         * SecureContext.) If SNICallback wasn't provided the default callback
         * with high-level API will be used (see below).
         */
        SNICallback?: ((servername: string, cb: (err: Error | null, ctx?: SecureContext) => void) => void) | undefined;
        /**
         * If true the server will reject any connection which is not
         * authorized with the list of supplied CAs. This option only has an
         * effect if requestCert is true.
         * @default true
         */
        rejectUnauthorized?: boolean | undefined;
    }
    interface TlsOptions extends SecureContextOptions, CommonConnectionOptions, net.ServerOpts {
        /**
         * Abort the connection if the SSL/TLS handshake does not finish in the
         * specified number of milliseconds. A 'tlsClientError' is emitted on
         * the tls.Server object whenever a handshake times out. Default:
         * 120000 (120 seconds).
         */
        handshakeTimeout?: number | undefined;
        /**
         * The number of seconds after which a TLS session created by the
         * server will no longer be resumable. See Session Resumption for more
         * information. Default: 300.
         */
        sessionTimeout?: number | undefined;
        /**
         * 48-bytes of cryptographically strong pseudo-random data.
         */
        ticketKeys?: Buffer | undefined;
        /**
         *
         * @param socket
         * @param identity identity parameter sent from the client.
         * @return pre-shared key that must either be
         * a buffer or `null` to stop the negotiation process. Returned PSK must be
         * compatible with the selected cipher's digest.
         *
         * When negotiating TLS-PSK (pre-shared keys), this function is called
         * with the identity provided by the client.
         * If the return value is `null` the negotiation process will stop and an
         * "unknown_psk_identity" alert message will be sent to the other party.
         * If the server wishes to hide the fact that the PSK identity was not known,
         * the callback must provide some random data as `psk` to make the connection
         * fail with "decrypt_error" before negotiation is finished.
         * PSK ciphers are disabled by default, and using TLS-PSK thus
         * requires explicitly specifying a cipher suite with the `ciphers` option.
         * More information can be found in the RFC 4279.
         */
        pskCallback?(socket: TLSSocket, identity: string): DataView | NodeJS.TypedArray | null;
        /**
         * hint to send to a client to help
         * with selecting the identity during TLS-PSK negotiation. Will be ignored
         * in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be
         * emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.
         */
        pskIdentityHint?: string | undefined;
    }
    interface PSKCallbackNegotation {
        psk: DataView | NodeJS.TypedArray;
        identity: string;
    }
    interface ConnectionOptions extends SecureContextOptions, CommonConnectionOptions {
        host?: string | undefined;
        port?: number | undefined;
        path?: string | undefined; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.
        socket?: stream.Duplex | undefined; // Establish secure connection on a given socket rather than creating a new socket
        checkServerIdentity?: typeof checkServerIdentity | undefined;
        servername?: string | undefined; // SNI TLS Extension
        session?: Buffer | undefined;
        minDHSize?: number | undefined;
        lookup?: net.LookupFunction | undefined;
        timeout?: number | undefined;
        /**
         * When negotiating TLS-PSK (pre-shared keys), this function is called
         * with optional identity `hint` provided by the server or `null`
         * in case of TLS 1.3 where `hint` was removed.
         * It will be necessary to provide a custom `tls.checkServerIdentity()`
         * for the connection as the default one will try to check hostname/IP
         * of the server against the certificate but that's not applicable for PSK
         * because there won't be a certificate present.
         * More information can be found in the RFC 4279.
         *
         * @param hint message sent from the server to help client
         * decide which identity to use during negotiation.
         * Always `null` if TLS 1.3 is used.
         * @returns Return `null` to stop the negotiation process. `psk` must be
         * compatible with the selected cipher's digest.
         * `identity` must use UTF-8 encoding.
         */
        pskCallback?(hint: string | null): PSKCallbackNegotation | null;
    }
    /**
     * Accepts encrypted connections using TLS or SSL.
     * @since v0.3.2
     */
    class Server extends net.Server {
        constructor(secureConnectionListener?: (socket: TLSSocket) => void);
        constructor(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void);
        /**
         * The `server.addContext()` method adds a secure context that will be used if
         * the client request's SNI name matches the supplied `hostname` (or wildcard).
         *
         * When there are multiple matching contexts, the most recently added one is
         * used.
         * @since v0.5.3
         * @param hostname A SNI host name or wildcard (e.g. `'*'`)
         * @param context An object containing any of the possible properties from the {@link createSecureContext} `options` arguments (e.g. `key`, `cert`, `ca`, etc), or a TLS context object created
         * with {@link createSecureContext} itself.
         */
        addContext(hostname: string, context: SecureContextOptions): void;
        /**
         * Returns the session ticket keys.
         *
         * See `Session Resumption` for more information.
         * @since v3.0.0
         * @return A 48-byte buffer containing the session ticket keys.
         */
        getTicketKeys(): Buffer;
        /**
         * The `server.setSecureContext()` method replaces the secure context of an
         * existing server. Existing connections to the server are not interrupted.
         * @since v11.0.0
         * @param options An object containing any of the possible properties from the {@link createSecureContext} `options` arguments (e.g. `key`, `cert`, `ca`, etc).
         */
        setSecureContext(options: SecureContextOptions): void;
        /**
         * Sets the session ticket keys.
         *
         * Changes to the ticket keys are effective only for future server connections.
         * Existing or currently pending server connections will use the previous keys.
         *
         * See `Session Resumption` for more information.
         * @since v3.0.0
         * @param keys A 48-byte buffer containing the session ticket keys.
         */
        setTicketKeys(keys: Buffer): void;
        /**
         * events.EventEmitter
         * 1. tlsClientError
         * 2. newSession
         * 3. OCSPRequest
         * 4. resumeSession
         * 5. secureConnection
         * 6. keylog
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        addListener(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void): this;
        addListener(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        addListener(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void): this;
        addListener(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        addListener(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'tlsClientError', err: Error, tlsSocket: TLSSocket): boolean;
        emit(event: 'newSession', sessionId: Buffer, sessionData: Buffer, callback: () => void): boolean;
        emit(event: 'OCSPRequest', certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void): boolean;
        emit(event: 'resumeSession', sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void): boolean;
        emit(event: 'secureConnection', tlsSocket: TLSSocket): boolean;
        emit(event: 'keylog', line: Buffer, tlsSocket: TLSSocket): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        on(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void): this;
        on(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        on(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void): this;
        on(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        on(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        once(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void): this;
        once(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        once(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void): this;
        once(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        once(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        prependListener(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void): this;
        prependListener(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        prependListener(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void): this;
        prependListener(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        prependListener(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        prependOnceListener(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void): this;
        prependOnceListener(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        prependOnceListener(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void): this;
        prependOnceListener(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        prependOnceListener(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
    }
    /**
     * @deprecated since v0.11.3 Use `tls.TLSSocket` instead.
     */
    interface SecurePair {
        encrypted: TLSSocket;
        cleartext: TLSSocket;
    }
    type SecureVersion = 'TLSv1.3' | 'TLSv1.2' | 'TLSv1.1' | 'TLSv1';
    interface SecureContextOptions {
        /**
         * If set, this will be called when a client opens a connection using the ALPN extension.
         * One argument will be passed to the callback: an object containing `servername` and `protocols` fields,
         * respectively containing the server name from the SNI extension (if any) and an array of
         * ALPN protocol name strings. The callback must return either one of the strings listed in `protocols`,
         * which will be returned to the client as the selected ALPN protocol, or `undefined`,
         * to reject the connection with a fatal alert. If a string is returned that does not match one of
         * the client's ALPN protocols, an error will be thrown.
         * This option cannot be used with the `ALPNProtocols` option, and setting both options will throw an error.
         */
        ALPNCallback?: ((arg: { servername: string; protocols: string[] }) => string | undefined) | undefined;
        /**
         * Optionally override the trusted CA certificates. Default is to trust
         * the well-known CAs curated by Mozilla. Mozilla's CAs are completely
         * replaced when CAs are explicitly specified using this option.
         */
        ca?: string | Buffer | Array<string | Buffer> | undefined;
        /**
         *  Cert chains in PEM format. One cert chain should be provided per
         *  private key. Each cert chain should consist of the PEM formatted
         *  certificate for a provided private key, followed by the PEM
         *  formatted intermediate certificates (if any), in order, and not
         *  including the root CA (the root CA must be pre-known to the peer,
         *  see ca). When providing multiple cert chains, they do not have to
         *  be in the same order as their private keys in key. If the
         *  intermediate certificates are not provided, the peer will not be
         *  able to validate the certificate, and the handshake will fail.
         */
        cert?: string | Buffer | Array<string | Buffer> | undefined;
        /**
         *  Colon-separated list of supported signature algorithms. The list
         *  can contain digest algorithms (SHA256, MD5 etc.), public key
         *  algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g
         *  'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).
         */
        sigalgs?: string | undefined;
        /**
         * Cipher suite specification, replacing the default. For more
         * information, see modifying the default cipher suite. Permitted
         * ciphers can be obtained via tls.getCiphers(). Cipher names must be
         * uppercased in order for OpenSSL to accept them.
         */
        ciphers?: string | undefined;
        /**
         * Name of an OpenSSL engine which can provide the client certificate.
         */
        clientCertEngine?: string | undefined;
        /**
         * PEM formatted CRLs (Certificate Revocation Lists).
         */
        crl?: string | Buffer | Array<string | Buffer> | undefined;
        /**
         * `'auto'` or custom Diffie-Hellman parameters, required for non-ECDHE perfect forward secrecy.
         * If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available.
         * ECDHE-based perfect forward secrecy will still be available.
         */
        dhparam?: string | Buffer | undefined;
        /**
         * A string describing a named curve or a colon separated list of curve
         * NIDs or names, for example P-521:P-384:P-256, to use for ECDH key
         * agreement. Set to auto to select the curve automatically. Use
         * crypto.getCurves() to obtain a list of available curve names. On
         * recent releases, openssl ecparam -list_curves will also display the
         * name and description of each available elliptic curve. Default:
         * tls.DEFAULT_ECDH_CURVE.
         */
        ecdhCurve?: string | undefined;
        /**
         * Attempt to use the server's cipher suite preferences instead of the
         * client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be
         * set in secureOptions
         */
        honorCipherOrder?: boolean | undefined;
        /**
         * Private keys in PEM format. PEM allows the option of private keys
         * being encrypted. Encrypted keys will be decrypted with
         * options.passphrase. Multiple keys using different algorithms can be
         * provided either as an array of unencrypted key strings or buffers,
         * or an array of objects in the form {pem: <string|buffer>[,
         * passphrase: <string>]}. The object form can only occur in an array.
         * object.passphrase is optional. Encrypted keys will be decrypted with
         * object.passphrase if provided, or options.passphrase if it is not.
         */
        key?: string | Buffer | Array<string | Buffer | KeyObject> | undefined;
        /**
         * Name of an OpenSSL engine to get private key from. Should be used
         * together with privateKeyIdentifier.
         */
        privateKeyEngine?: string | undefined;
        /**
         * Identifier of a private key managed by an OpenSSL engine. Should be
         * used together with privateKeyEngine. Should not be set together with
         * key, because both options define a private key in different ways.
         */
        privateKeyIdentifier?: string | undefined;
        /**
         * Optionally set the maximum TLS version to allow. One
         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
         * `secureProtocol` option, use one or the other.
         * **Default:** `'TLSv1.3'`, unless changed using CLI options. Using
         * `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to
         * `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.
         */
        maxVersion?: SecureVersion | undefined;
        /**
         * Optionally set the minimum TLS version to allow. One
         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
         * `secureProtocol` option, use one or the other.  It is not recommended to use
         * less than TLSv1.2, but it may be required for interoperability.
         * **Default:** `'TLSv1.2'`, unless changed using CLI options. Using
         * `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to
         * `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to
         * 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.
         */
        minVersion?: SecureVersion | undefined;
        /**
         * Shared passphrase used for a single private key and/or a PFX.
         */
        passphrase?: string | undefined;
        /**
         * PFX or PKCS12 encoded private key and certificate chain. pfx is an
         * alternative to providing key and cert individually. PFX is usually
         * encrypted, if it is, passphrase will be used to decrypt it. Multiple
         * PFX can be provided either as an array of unencrypted PFX buffers,
         * or an array of objects in the form {buf: <string|buffer>[,
         * passphrase: <string>]}. The object form can only occur in an array.
         * object.passphrase is optional. Encrypted PFX will be decrypted with
         * object.passphrase if provided, or options.passphrase if it is not.
         */
        pfx?: string | Buffer | Array<string | Buffer | PxfObject> | undefined;
        /**
         * Optionally affect the OpenSSL protocol behavior, which is not
         * usually necessary. This should be used carefully if at all! Value is
         * a numeric bitmask of the SSL_OP_* options from OpenSSL Options
         */
        secureOptions?: number | undefined; // Value is a numeric bitmask of the `SSL_OP_*` options
        /**
         * Legacy mechanism to select the TLS protocol version to use, it does
         * not support independent control of the minimum and maximum version,
         * and does not support limiting the protocol to TLSv1.3. Use
         * minVersion and maxVersion instead. The possible values are listed as
         * SSL_METHODS, use the function names as strings. For example, use
         * 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow
         * any TLS protocol version up to TLSv1.3. It is not recommended to use
         * TLS versions less than 1.2, but it may be required for
         * interoperability. Default: none, see minVersion.
         */
        secureProtocol?: string | undefined;
        /**
         * Opaque identifier used by servers to ensure session state is not
         * shared between applications. Unused by clients.
         */
        sessionIdContext?: string | undefined;
        /**
         * 48-bytes of cryptographically strong pseudo-random data.
         * See Session Resumption for more information.
         */
        ticketKeys?: Buffer | undefined;
        /**
         * The number of seconds after which a TLS session created by the
         * server will no longer be resumable. See Session Resumption for more
         * information. Default: 300.
         */
        sessionTimeout?: number | undefined;
    }
    interface SecureContext {
        context: any;
    }
    /**
     * Verifies the certificate `cert` is issued to `hostname`.
     *
     * Returns [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, populating it with `reason`, `host`, and `cert` on
     * failure. On success, returns [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type).
     *
     * This function is intended to be used in combination with the`checkServerIdentity` option that can be passed to {@link connect} and as
     * such operates on a `certificate object`. For other purposes, consider using `x509.checkHost()` instead.
     *
     * This function can be overwritten by providing an alternative function as the`options.checkServerIdentity` option that is passed to `tls.connect()`. The
     * overwriting function can call `tls.checkServerIdentity()` of course, to augment
     * the checks done with additional verification.
     *
     * This function is only called if the certificate passed all other checks, such as
     * being issued by trusted CA (`options.ca`).
     *
     * Earlier versions of Node.js incorrectly accepted certificates for a given`hostname` if a matching `uniformResourceIdentifier` subject alternative name
     * was present (see [CVE-2021-44531](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531)). Applications that wish to accept`uniformResourceIdentifier` subject alternative names can use
     * a custom`options.checkServerIdentity` function that implements the desired behavior.
     * @since v0.8.4
     * @param hostname The host name or IP address to verify the certificate against.
     * @param cert A `certificate object` representing the peer's certificate.
     */
    function checkServerIdentity(hostname: string, cert: PeerCertificate): Error | undefined;
    /**
     * Creates a new {@link Server}. The `secureConnectionListener`, if provided, is
     * automatically set as a listener for the `'secureConnection'` event.
     *
     * The `ticketKeys` options is automatically shared between `node:cluster` module
     * workers.
     *
     * The following illustrates a simple echo server:
     *
     * ```js
     * const tls = require('node:tls');
     * const fs = require('node:fs');
     *
     * const options = {
     *   key: fs.readFileSync('server-key.pem'),
     *   cert: fs.readFileSync('server-cert.pem'),
     *
     *   // This is necessary only if using client certificate authentication.
     *   requestCert: true,
     *
     *   // This is necessary only if the client uses a self-signed certificate.
     *   ca: [ fs.readFileSync('client-cert.pem') ],
     * };
     *
     * const server = tls.createServer(options, (socket) => {
     *   console.log('server connected',
     *               socket.authorized ? 'authorized' : 'unauthorized');
     *   socket.write('welcome!\n');
     *   socket.setEncoding('utf8');
     *   socket.pipe(socket);
     * });
     * server.listen(8000, () => {
     *   console.log('server bound');
     * });
     * ```
     *
     * The server can be tested by connecting to it using the example client from {@link connect}.
     * @since v0.3.2
     */
    function createServer(secureConnectionListener?: (socket: TLSSocket) => void): Server;
    function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;
    /**
     * The `callback` function, if specified, will be added as a listener for the `'secureConnect'` event.
     *
     * `tls.connect()` returns a {@link TLSSocket} object.
     *
     * Unlike the `https` API, `tls.connect()` does not enable the
     * SNI (Server Name Indication) extension by default, which may cause some
     * servers to return an incorrect certificate or reject the connection
     * altogether. To enable SNI, set the `servername` option in addition
     * to `host`.
     *
     * The following illustrates a client for the echo server example from {@link createServer}:
     *
     * ```js
     * // Assumes an echo server that is listening on port 8000.
     * const tls = require('node:tls');
     * const fs = require('node:fs');
     *
     * const options = {
     *   // Necessary only if the server requires client certificate authentication.
     *   key: fs.readFileSync('client-key.pem'),
     *   cert: fs.readFileSync('client-cert.pem'),
     *
     *   // Necessary only if the server uses a self-signed certificate.
     *   ca: [ fs.readFileSync('server-cert.pem') ],
     *
     *   // Necessary only if the server's cert isn't for "localhost".
     *   checkServerIdentity: () => { return null; },
     * };
     *
     * const socket = tls.connect(8000, options, () => {
     *   console.log('client connected',
     *               socket.authorized ? 'authorized' : 'unauthorized');
     *   process.stdin.pipe(socket);
     *   process.stdin.resume();
     * });
     * socket.setEncoding('utf8');
     * socket.on('data', (data) => {
     *   console.log(data);
     * });
     * socket.on('end', () => {
     *   console.log('server ends connection');
     * });
     * ```
     * @since v0.11.3
     */
    function connect(options: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;
    function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;
    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;
    /**
     * Creates a new secure pair object with two streams, one of which reads and writes
     * the encrypted data and the other of which reads and writes the cleartext data.
     * Generally, the encrypted stream is piped to/from an incoming encrypted data
     * stream and the cleartext one is used as a replacement for the initial encrypted
     * stream.
     *
     * `tls.createSecurePair()` returns a `tls.SecurePair` object with `cleartext` and`encrypted` stream properties.
     *
     * Using `cleartext` has the same API as {@link TLSSocket}.
     *
     * The `tls.createSecurePair()` method is now deprecated in favor of`tls.TLSSocket()`. For example, the code:
     *
     * ```js
     * pair = tls.createSecurePair(// ... );
     * pair.encrypted.pipe(socket);
     * socket.pipe(pair.encrypted);
     * ```
     *
     * can be replaced by:
     *
     * ```js
     * secureSocket = tls.TLSSocket(socket, options);
     * ```
     *
     * where `secureSocket` has the same API as `pair.cleartext`.
     * @since v0.3.2
     * @deprecated Since v0.11.3 - Use {@link TLSSocket} instead.
     * @param context A secure context object as returned by `tls.createSecureContext()`
     * @param isServer `true` to specify that this TLS connection should be opened as a server.
     * @param requestCert `true` to specify whether a server should request a certificate from a connecting client. Only applies when `isServer` is `true`.
     * @param rejectUnauthorized If not `false` a server automatically reject clients with invalid certificates. Only applies when `isServer` is `true`.
     */
    function createSecurePair(context?: SecureContext, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;
    /**
     * {@link createServer} sets the default value of the `honorCipherOrder` option
     * to `true`, other APIs that create secure contexts leave it unset.
     *
     * {@link createServer} uses a 128 bit truncated SHA1 hash value generated
     * from `process.argv` as the default value of the `sessionIdContext` option, other
     * APIs that create secure contexts have no default value.
     *
     * The `tls.createSecureContext()` method creates a `SecureContext` object. It is
     * usable as an argument to several `tls` APIs, such as `server.addContext()`,
     * but has no public methods. The {@link Server} constructor and the {@link createServer} method do not support the `secureContext` option.
     *
     * A key is _required_ for ciphers that use certificates. Either `key` or`pfx` can be used to provide it.
     *
     * If the `ca` option is not given, then Node.js will default to using [Mozilla's publicly trusted list of
     * CAs](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt).
     *
     * Custom DHE parameters are discouraged in favor of the new `dhparam: 'auto'`option. When set to `'auto'`, well-known DHE parameters of sufficient strength
     * will be selected automatically. Otherwise, if necessary, `openssl dhparam` can
     * be used to create custom parameters. The key length must be greater than or
     * equal to 1024 bits or else an error will be thrown. Although 1024 bits is
     * permissible, use 2048 bits or larger for stronger security.
     * @since v0.11.13
     */
    function createSecureContext(options?: SecureContextOptions): SecureContext;
    /**
     * Returns an array with the names of the supported TLS ciphers. The names are
     * lower-case for historical reasons, but must be uppercased to be used in
     * the `ciphers` option of {@link createSecureContext}.
     *
     * Not all supported ciphers are enabled by default. See `Modifying the default TLS cipher suite`.
     *
     * Cipher names that start with `'tls_'` are for TLSv1.3, all the others are for
     * TLSv1.2 and below.
     *
     * ```js
     * console.log(tls.getCiphers()); // ['aes128-gcm-sha256', 'aes128-sha', ...]
     * ```
     * @since v0.10.2
     */
    function getCiphers(): string[];
    /**
     * The default curve name to use for ECDH key agreement in a tls server.
     * The default value is 'auto'. See tls.createSecureContext() for further
     * information.
     */
    let DEFAULT_ECDH_CURVE: string;
    /**
     * The default value of the maxVersion option of
     * tls.createSecureContext(). It can be assigned any of the supported TLS
     * protocol versions, 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default:
     * 'TLSv1.3', unless changed using CLI options. Using --tls-max-v1.2 sets
     * the default to 'TLSv1.2'. Using --tls-max-v1.3 sets the default to
     * 'TLSv1.3'. If multiple of the options are provided, the highest maximum
     * is used.
     */
    let DEFAULT_MAX_VERSION: SecureVersion;
    /**
     * The default value of the minVersion option of tls.createSecureContext().
     * It can be assigned any of the supported TLS protocol versions,
     * 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default: 'TLSv1.2', unless
     * changed using CLI options. Using --tls-min-v1.0 sets the default to
     * 'TLSv1'. Using --tls-min-v1.1 sets the default to 'TLSv1.1'. Using
     * --tls-min-v1.3 sets the default to 'TLSv1.3'. If multiple of the options
     * are provided, the lowest minimum is used.
     */
    let DEFAULT_MIN_VERSION: SecureVersion;
    /**
     * The default value of the ciphers option of tls.createSecureContext().
     * It can be assigned any of the supported OpenSSL ciphers.
     * Defaults to the content of crypto.constants.defaultCoreCipherList, unless
     * changed using CLI options using --tls-default-ciphers.
     */
    let DEFAULT_CIPHERS: string;
    /**
     * An immutable array of strings representing the root certificates (in PEM
     * format) used for verifying peer certificates. This is the default value
     * of the ca option to tls.createSecureContext().
     */
    const rootCertificates: ReadonlyArray<string>;
}
declare module 'node:tls' {
    export * from 'tls';
}
